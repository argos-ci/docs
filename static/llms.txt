// File: introduction

import { XCard } from "@site/src/components/Card";
import { HelpSection } from "@site/src/partials";

import CypressLogo from "@site/src/img/frameworks/cypress.png";
import PlaywrightLogo from "@site/src/img/frameworks/playwright.png";
import PuppeteerLogo from "@site/src/img/frameworks/puppeteer.png";
import NextjsLogo from "@site/src/img/frameworks/next-js.png";
import ReactRouterLogo from "@site/src/img/frameworks/react-router.png";
import WebdriverIOLogo from "@site/src/img/frameworks/webdriverio.png";
import StorybookLogo from "@site/src/img/frameworks/storybook.png";
import OthersLogo from "@site/src/img/frameworks/others.png";
import CameraIcon from "@site/src/img/camera-icon.png";
import GithubLogo from "@site/src/img/github-logo.png";
import UploadIcon from "@site/src/img/upload-icon.png";
import CheckIcon from "@site/src/img/check-icon.png";
import TeamSelectIcon from "@site/src/img/team-select.png";
import PlanCardIcon from "@site/src/img/plan-card.png";

# Introduction

Argos detects unintended visual changes in your UI, helping teams maintain high product quality as they ship faster.

## Quick start

Learn how to setup Argos in your project:

<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 flex-wrap">
  <XCard
    logo={PlaywrightLogo}
    text="Playwright Quickstart"
    to="/quickstart/playwright"
  />
  <XCard
    logo={StorybookLogo}
    text="Storybook Quickstart"
    to="/quickstart/storybook"
  />
  <XCard
    logo={CypressLogo}
    text="Cypress Quickstart"
    to="/quickstart/cypress"
  />
  <XCard
    logo={WebdriverIOLogo}
    text="WebdriverIO Quickstart"
    to="/quickstart/webdriverio"
  />
  <XCard
    logo={PuppeteerLogo}
    text="Puppeteer Quickstart"
    to="/quickstart/puppeteer"
  />
  <XCard logo={NextjsLogo} text="Next.js Quickstart" to="/quickstart/next-js" />
  <XCard
    logo={ReactRouterLogo}
    text="React Router Quickstart"
    to="/quickstart/react-router"
  />
  <XCard
    logo={OthersLogo}
    text="Any E2E Quickstart"
    to="/quickstart/with-any-e2e-tool"
  />
</div>

## Explore

Dig deeper into Argos topics:

<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 flex-wrap">
  <XCard text="Baselines & monitoring" to="/baseline-build" />
  <XCard text="Integrations" to="/integrations" />
  <XCard text="Flaky test detection" to="/flaky-test-detection" />
</div>

---

// File: learn/account-and-access/account-management

# Account Management

When you sign up for Argos, you create an account that manages your projects and subscriptions.  
Argos offers three types of plans:

- [Hobby](/pricing-plans#hobby-plan)
- [Pro](/pricing-plans#pro-plan)
- [Enterprise](/pricing-plans#enterprise-plan)

Each plan provides different features and resources to match your needs.

You can sign up with **Google**, **GitHub**, or **GitLab**.

---

## Signing up with a Git provider

Argos supports the following Git providers:

- [GitHub](/github)
- [GitLab](/gitlab)

When you sign up, youâ€™ll be asked to authorize Argos to access your Git provider.  
This connection becomes your default login method.

After signing up, you can manage login methods in your **Personal Settings**.

---

## Login methods and connections

To manage login connections:

1. Select your profile picture in the top-right corner of the dashboard.
2. Choose **Settings**.
3. Open the **Authentication** section.

![The Authentication section of your account settings.](./account-management/authentication.png)

### Logging in with SAML Single Sign-On (SSO)

SAML SSO allows Enterprise users to log in with their organizationâ€™s identity provider.  
Your team administrator must configure this option. To upgrade to Enterprise, [contact sales](https://argos-ci.com/contact).

### Choosing a connection when creating a project

When you create your first project, youâ€™ll be asked to connect a Git provider.  
This connection is required and will also serve as a login method.

---

## Teams

Teams let you collaborate on projects and share resources.

### Creating a team

1. Click the **scope selector** in the top-left of the navbar.
2. Choose **Create new team**.
3. Enter a team name.
4. By default, new teams start on the **Pro plan**. To switch plans, [contact us](https://argos-ci.com/contact).

Team settings and members can be managed from the teamâ€™s settings page.

### Free Pro trial

Your first team automatically starts with a **14-day free trial of Argos Pro**.  
The trial includes unlimited users and **35,000 free screenshots**.

### Team membership

Owners can invite new members using an invitation link found in **Team Settings**.  
See [Roles and permissions](/team-members-and-roles#owner-role) for details.

#### Inviting teammates

1. From the dashboard, select your team from the scope selector
2. Open the **Settings** tab and go to the **Members** section
3. Click **Invite Link** and copy the generated link
4. Share the link with anyone you want to join the team

:::note

Public repositories on Argos are accessible to everyone.

:::

### Leaving a team

You cannot leave a team if you are the **last owner** or the **last member**.

To leave a team:

1. If necessary, assign another owner first
2. Go to your teamâ€™s **Settings** tab and go to the **Members** section
3. Scroll to **Leave Team** and select **Leave Team**
4. Confirm the action
5. If you are the last member, [delete the team](#deleting-a-team) instead

### Deleting a team

1. Remove all team projects
2. Open the teamâ€™s **Settings** tab
3. Scroll to **Delete Team** and select **Delete Team**
4. Confirm the action

---

## Managing emails

To access email settings:

1. Select your avatar in the top-right corner
2. Choose **Settings**
3. Scroll to **Emails** section
4. From here, you can [add](#adding-a-new-email-address), [remove](#removing-an-email-address), or [change](#changing-your-primary-email-address) your primary email

## Adding a new email address

1. In the **Emails** section, click **Add Another**
2. Verify the new address using the link sent to your inbox
3. Once verified, any email address on your account can be used to log in

![Your account email addresses.](./account-management/email-management.png)

## Changing your primary email address

Your primary email is used for Argos notifications.

To change it:

- Add and verify a new email.
- Open the dot menu next to the address and choose **Set as Primary**.

![Setting your primary email address.](./account-management/set-email-as-primary.png)

## Removing an email address

To remove an address, use the **Delete** option in the dot menu.

> Note: You must set a new primary email before removing the current one.

## Resolving "Account already attached" issues

If you see the error message:

> **Your _GitHub|GitLab|Google_ account is already linked to another Argos account**

it means the provider account you are trying to connect is already associated with a different Argos account.

### Steps to fix

1. **Log out of Argos**
   - Select your avatar in the top-right corner, then select **Log out**.

2. **Log back in with your provider**
   - From the login page, choose **Continue with _GitHub|GitLab|Google_**.
   - This will sign you into the Argos account that currently owns your provider link.

3. **Disconnect or delete the account**
   - Once logged in, select your avatar in the top-right corner, choose **Settings**.
   - Select **Authentication** from the sidebar.
   - Find the _GitHub|GitLab|Google_ connection, select the vertical ellipsis (â‹®), and select **Disconnect**.
   - Alternatively, if the account is no longer needed, you can delete it entirely from **Account Settings â†’ General**.

4. **Log out again**
   - Return to the login page.

5. **Reconnect with the right account**
   - Log back in with the account you want to use.
   - From **Account Settings â†’ Connections**, link your provider account.

After completing these steps, your provider account will be linked to the correct Argos account.

---

// File: learn/account-and-access/github-sso

import enablingGithubSSO from "./github-sso/enable-github-sso.png";
import githubSSOEnabled from "./github-sso/github-sso-enabled.png";

# GitHub Single Sign-On

Streamline access with GitHub SSO: Integrate your Argos team and GitHub organization for seamless member sync, enhancing security and management ease.

### Enabling Feature

1. Navigate to team settings.
2. Click "Enable and Pay" under the "GitHub Single Sign-On" section.
3. Select your team, authorize Argos on GitHub, and the feature will be activated.

<img
  src={enablingGithubSSO}
  alt="Enable GitHub SSO"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

### Disabling Feature

In team settings, click "Disable" under the "GitHub Single Sign-On" section and confirm. The "owners" will remain as a member of the team.

<img
  src={githubSSOEnabled}
  alt="GitHub SSO enabled"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

## Availability and Payment

The cost of this add-on is $50 / month and it's exclusive to Stripe subscribers.

When you enable GitHub SSO, your team will be charged for the feature on your monthly billing. You will see "Add-on: GitHub SSO" line on your invoice. This feature can be disabled at any time.

---

// File: learn/account-and-access/team-members-and-roles

# Team Members & Roles

Learn how to manage team members on Argos, and how to assign roles to each member with role-based access control (RBAC).

:::note

Team roles are available on Pro and Enterprise plans

:::

Teams are made up of members, and each member of a team can be assigned a role. These roles define what you can and cannot do within a team on Argos.

As your project scales and you add more team members, you can assign them roles to ensure that they have the right permissions to work on your projects.

## Access Roles Overview

Argos distinguishes between different roles to help manage team members' access levels and permissions. These roles are categorized into two groups: team level and project level roles. Team level roles are applicable to the entire team, affecting all projects within that team. Project level roles are confined to individual projects.

![Team and project roles relationship diagram](./team-members-and-roles/permissions-diagram.png)

The two groups are further divided into specific roles, each with its own set of permissions and responsibilities. These roles are designed to provide a balance between autonomy and security, ensuring that team members have the access they need to perform their tasks while maintaining the integrity of the team and its resources.

- [Team level roles](#team-level-roles): Users who have access to all projects within a team
  - [Owner](#owner-role)
  - [Member](#member-role)
  - [Contributor](#contributor-role)
- [Project level roles](#project-level-roles): Users who have restricted access at the project level. Only contributors can have configurable project roles
  - [Project Administrator](#project-administrator)
  - [Project Reviewer](#project-reviewer)
  - [Project Viewer](#project-reviewer)

## Team level roles

:::note

Team level roles are available on Pro and Enterprise plans

:::

Team level roles are designed to provide a broad level of control and access to the team as a whole. These roles are assigned to individuals and apply to all projects within the team, ensuring centralized control and access while upholding the team's security and integrity.

- **[Owner](#owner-role)** and **[Member](#member-role)**: Have the highest level of control. They can manage, modify, and oversee the team's settings, and all projects
- **[Contributor](#contributor-role)**: A unique role that can be configured to have any of the project level roles or none. If a contributor has no assigned project role, they won't be able to access that specific project. Only contributors can have configurable project roles

### Owner role

:::note

The owner role is available on Pro and Enterprise plans

:::

The owner role is the highest level of authority within a team, possessing comprehensive access and control over all team and project settings.

#### Key responsibilities

- Oversee and manage all team resources and projects
- Modify team settings, including billing
- Grant or revoke access to team projects and determine project-specific roles for members
- Access and modify all projects, including their settings

#### Access and permissions

Owners have unrestricted access to all team functionalities, can modify all settings, and change other members' roles.

Team owners inherently act as project administrators for every project within the team, ensuring that they can manage individual projects' settings and deployments.

#### Additional information

Teams can have more than one owner. For continuity, we recommend that at least two individuals have owner permissions. Additional owners can be added without any impact on existing ownership. Keep in mind that role changes, including assignment and revocation of team member roles, are an exclusive capability of those with the owner role.

### Member role

:::note

The member role is available on Pro and Enterprise plans

:::

Members are the most common role in the team. They have access to all projects but do not have access to team management settings.

#### Key responsibilities

- See and review builds
- Access and modify all projects, including their settings

#### Access and permissions

Members have full autonomy to review projects or edit settings. However they can't edit team settings or invite new users to the team, only owners can.

### Contributor role

:::note

The contributor role is available on Enterprise plans

:::

Contributors offer flexibility in access control at the project level. To limit team members' access at the project level, they must first be assigned the contributor role. Only after being assigned the contributor role can they receive project-level roles. **Contributors have no access to projects unless explicitly assigned.**

Contributors may have project-specific role assignments, with the potential for comprehensive control over assigned projects only.

#### Key responsibilities

- Typically assigned to specific projects based on expertise and needs
- Review builds and edit project settings â€” _Depending on their assigned [project role](#project-level-roles)_

#### Access and permissions

Contributors can be assigned to specific projects and have the same permissions as [project administrators](#project-administrator), [project reviewers](#project-reviewer), or [project viewers](#project-viewer). They can also be assigned no project role, which means they won't be able to access that specific project.

See the [Project level roles](#project-level-roles) section for more information on project roles.

## Project level roles

:::note

Project level roles are available on Enterprise plans

:::

Project level roles provide fine-grained control and access to specific projects within a team. These roles are assigned to individuals and are restricted to the projects they're assigned to, allowing for precise access control while preserving the overarching security and integrity of the team.

- **[Project Administrator](#project-administrator)**: Team owners and members inherently act as project administrators for every project. Project administrators can review builds, manage all project settings, and manage production environment variables
- **[Project Reviewer](#project-reviewer)**: Can review builds.
- **[Project Viewer](#project-viewer)**: Has read-only access to a specific project.

### Project Administrator

:::note

The project administrator role is available on Enterprise plans

:::

Project reviewers play a key role in working on projects, mirroring the functions of team members, but with a narrowed project focus.

#### Key responsibilities

- Review builds

### Project Reviewer

:::note

The project reviewer role is available on Enterprise plans

:::

Project administrators hold significant authority at the project level, operating as the project-level counterparts to team members and owners.

#### Key responsibilities

- Review builds
- Govern project settings
- Add contributors to project

#### Access and permission

Their authority doesn't extend across all projects within the team. Project administrators are restricted to the projects they're assigned to.

### Project Viewer

:::note

The project viewer role is available on Enterprise plans

:::

Adopting an observational role within the project scope, they ensure transparency and understanding across projects.

#### Key responsibilities

- View and inspect all builds and screenshots

## Default Project Roles

When you set a default role in a specific project, all of your teamâ€™s contributors will automatically inherit that default role when theyâ€™re granted access to that project. This feature helps you streamline role management and maintain consistent permissions for new contributors.

**To set a default role in a project:**

1. Navigate to the project's **Settings** page.
2. Scroll down to the **Access management** section.
3. Click on **Set default contributor level**.
4. Select the desired default role (Viewer, Reviewer, or Admin).
5. Click **Save**.

After setting this default, every team member with a role "contributor" will have access to this project with this default role. You can still override this by assigning a custom role to individual contributors later.

This approach simplifies onboarding, helps ensure consistent access levels, and reduces the time spent manually configuring roles.

---

// File: learn/billing/spend-management

# Spend Management

Learn how to get notified about you team's spend and block further usage when you reach your budget.

:::note

Spend management is available on Pro and Enterprise plans (usage based)

:::

Spend management is a way for you to notify or to automatically take action on your account when your team hits a set spend amount. The actions you can take are:

- [Receive a notification](#alert-threshold-notifications) when you reach certain thresholds of your spend amount
- [Pause the builds on all your projects](#pausing-projects)

:::warning

Setting a spend amount does not automatically stop usage. If you want to pause all your projects at a certain amount, you must [enable the option](#pausing-projects).

:::

The spend amount is set per billing cycle.

Setting the amount halfway through a billing cycle considers your current spend. You can increase or decrease your spend amount as needed. If you configure it below the current monthly spend, Spend Management will trigger any configured actions (including pausing all projects).

## What does Spend Management include?

The spend amount that you set covers additional screenshots that go beyond your plan usage for all projects on your team.

It does not include separate **add-ons**, which Argos charges per billing period.

### How Argos checks your spend amount

ercel checks your additional screenshots usage often to determine if you are approaching or have exceeded your spend amount. This check happens at every build processed by Argos.

## Managing your spend amount

To enable spend management, you must have an **Owner** role on your team.

1. From the dashboard, select your team from the scope selector
2. Select the **Settings** tab and go to the **Billings** section
3. Scroll to **Spend Management** and enable the switch:

![Spend Management Enabled](./spend-management/spend-management-section.jpg)

4. Set your spend amount at which you want to be notified or take action
5. Choose to [pause all projects](#pausing-projects) when you reach your spend amount

## Alert threshold notifications

When you set a spend amount, Argos will send an email to all your team owner members when spending on your team reaches **50%**, **75%**, and **100%** of the spend amount.

It's not currently possible to customize the alert threshold notifications.

## Pausing projects

Argos provides an option to automatically pause the builds for all of your projects when your spend amount is reached. This option is on by default.

1. In the **Spend Management** section of your team's settings, enable and set your **[spend amount](#managing-your-spend-amount)**
2. Ensure the **Pause builds** switch is **Enabled**
3. Confirm the action by entering the team slug and select **Continue**.
4. When your team reaches the spend amount, Argos automatically pauses the builds for all projects on your team

When you try to create a new build, you will get an error message that the builds are paused due to reaching the spend amount. **It will make your CI builds fail until you increase your spend amount or disable the pause builds option.**

### Unpausing projects

To unpause your projects, you must increase your spend amount or disable the pause builds option.

---

// File: learn/billing/subscription/pricing-plans

# Pricing plans

Argos offers flexible plans for individuals, teams, and enterprises. From the free Hobby Plan to fully customizable Enterprise options.

## Hobby Plan

Best for individuals and small projects.

- **Price:** Free
- **Screenshots included:** 5,000 / month
- **Extra screenshots:** Not available

## Pro Plan

Designed for teams, with usage-based pricing. See full details on our [Pricing page](https://argos-ci.com/pricing).

- **Starting price:** $100 / month
- **Screenshots included:** 35,000 / month
- **Extra screenshots:**
  - Standard: $0.004 per screenshot
  - Storybook: $0.0015 per screenshot

### GitHub Marketplace

You can also subscribe through GitHub Marketplace and pay via your GitHub invoice.  
Pro Plans are available in different sizes (S, M, L, XL) with increasing screenshot limits.  
See all options on our [GitHub Marketplace page](https://github.com/marketplace/argos-ci).

## Open-Source Plan

We sponsor selected [open-source projects](/open-source) with free usage, evaluated case by case.

## Enterprise Plan

For large organizations with custom requirements. Tailor your plan directly with us.

ðŸ‘‰ [Contact us](mailto:contact@argos-ci.com) to discuss your needs. Weâ€™ll help design the right plan for your business.

---

// File: learn/billing/subscription/open-source

# Open source

At Argos, we understand the value of open source projects and want to do our part in fostering and supporting the growth of the open source community.

## Qualification for Sponsorship

To consider your project for sponsorship, Argos requires that the following conditions are met:

The project must not be for commercial use.

- The project must be open source.
- The project's usage of Argos falls within reasonable use limits.
- The project must be willing to include the Argos banner below in the source repository's README.md file, pointing to `https://argos-ci.com`.
- The project must include a dofollow link to `https://argos-ci.com` on at least one page.
- The project should use a UTM tag in the format `?utm_source=[team-name]&utm_campaign=oss` for the banners.

<div style={{ textAlign: "center" }}>
  <img src="https://argos-ci.com/badge-large.svg" alt="Argos badge" />
</div>

## How to Apply for Sponsorship

If you wish to apply for sponsorship for your OSS (Open Source Software) project, please follow these steps:

1. Make sure your project fulfills all the sponsorship conditions outlined above.
2. Ensure that your project needs this level of sponsorship. Our free plan is quite generous and is often sufficient for smaller projects.
3. Send us an email at [contact@argos-ci.com](mailto:contact@argos-ci.com). In the email, confirm that your project meets all the sponsorship criteria and explain why the free tier of Argos doesn't cover your project's needs. Please include your Argos team slug and a link to your open source repository in the email.

---

// File: learn/billing/subscription/how-to-subscribe

import teamSelect from "@site/src/img/team-select.png";
import upgradeButton from "@site/src/img/upgrade-button.png";

# How to subscribe

Unlock Argos team features with a subscription. Upgrade your existing team or create a new one to access premium capabilities.

## Steps to Subscribe

:::note

A 14-day trial is available for the first team upgrade.

:::

1. If you do not have a team yet, [create a new team](https://app.argos-ci.com/teams/new). Otherwise, go to the settings of your existing team.

2. In the Plan section, click on the `Upgrade` button.

<img
  src={upgradeButton}
  alt="upgrade button"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

3. Choose the team you wish to upgrade.

<img
  src={teamSelect}
  alt="team select"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

4. You will be redirected to Stripe Checkout. Complete the payment form.

5. After the payment process is successfully completed, you will receive a confirmation email.

:::note

The payment will be processed at the end of the first month based on your usage.

:::

## Subscription via GitHub Marketplace

If you prefer subscribing via GitHub Marketplace, initiate the subscription on the [Argos Marketplace page](https://github.com/marketplace/argos-ci). Ensure that you upgrade the correct organization on the Marketplace.

---

// File: learn/billing/subscription/manage-subscription

import manageSubscriptionLink from "@site/src/img/manage-subscription-link.png";

# Manage subscription

Seamlessly manage your Argos subscription: view invoices, update payment methods, or cancel plans with ease.

1. Navigate to your team settings.
2. Click the "Manage your subscription" link located within the settings.

After performing these steps, you will be redirected to the platform of your payment provider.

<img
  src={manageSubscriptionLink}
  alt="Manage Subscription link"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

---

// File: learn/billing/subscription/usage-monitoring

import planCard from "@site/src/img/plan-card.png";

# Usage monitoring

Effortlessly track your monthly usage with Argos. Access your team's usage details in just a few clicks, ensuring transparency and informed decision-making.

Here's how you can access your team usage details:

1. From the dashboard, select your team from the scope selector
2. Select the **Settings** tab and go to the **Billing** section

<img
  src={planCard}
  alt="Plan card"
  className="rounded"
  style={{ marginBottom: 20, marginTop: 20 }}
/>

**Understanding consumption metrics**

#### Private project

The number of screenshots taken from private projects. These screenshots count towards your consumption limit and are subject to charges.

#### Public project

The number of screenshots generated from open-source projects.

## What happens if I exceed my plan's capacity?

When you're nearing the limit of your current plan, Argos will alert you accordingly.

Should you exceed your plan's limit, the ability to upload additional screenshots to Argos will be temporarily halted until the start of the next billing period.

### Hobby Plan

If your usage demands on the Hobby Plan exceed the limit, consider transitioning to a Team Plan. You can easily transfer your project to a newly created team.

### Limited Pro Plan

In case you surpass the threshold of your Limited Pro Plan, you'll need to [upgrade your plan](https://github.com/marketplace/argos-ci) to continue uploading screenshots seamlessly.

---

// File: learn/billing/subscription/invoiced-customers

# Invoiced customers

Discover how invoiced GitHub accounts affect subscribing to Argos' paid plan and explore alternative subscription options.

If you have a GitHub invoiced account and are looking to subscribe to Argos' paid plan through the GitHub Marketplace, you may have encountered the following error message:

> "Unfortunately, invoiced customers cannot purchase paid plans on the GitHub Marketplace."<br/> **â€” GitHub error message**

This error message can be confusing, but it simply means that if your GitHub account is set up to receive an invoice for your subscription rather than charging your credit card directly, you won't be able to use the GitHub Marketplace to subscribe to Argos.

Not to worry! You can still purchase an Argos' paid plan by [subscribing via Stripe](/how-to-subscribe).

---

// File: learn/fundamentals/diff-algorithm

# How Argos detects visual differences

Argos uses **deterministic pixel diffing**, not AI-based visual comparison.
Instead of compensating for flakiness, Argos focuses on eliminating it at the source. This keeps visual tests precise, explainable, and reliable over time.

## What Argos compares

Argos compares **rendered screenshots** and [**ARIA snapshots**](/playwright#aria-snapshots) produced by your E2E and Storybook tests.

Each snapshot is compared against a baseline using a **pixel-level diff algorithm** executed in multiple refinement passes.

The question we answer is intentionally simple:

> Did the UI visually change, or not?

No interpretation. No probability. No guesswork.

## The diff algorithm

Argos relies on the open source [**odiff** library](https://github.com/dmtrKovalenko/odiff) maintained by the talented Dmitriy Kovalenko.

Our full diff implementation is also open source and can be [inspected here](https://github.com/argos-ci/argos/blob/main/apps/backend/src/screenshot-diff/diff/image/index.ts).

### High-level flow

1. **Image normalization**  
   Resolution, color space, and alpha channels are aligned.

2. **Multiple diff passes**  
   Each pass uses different thresholds to detect both strict and subtle changes.

3. **Pixel clustering**  
   Random noise is separated from meaningful visual changes.

4. **Final diff output**  
   A diff mask and score are produced for review in Argos.

Running multiple passes allows Argos to stay strict while remaining resilient to minor, explainable noise.

## Why pixel diffing instead of AI

Some tools use AI or ML models to decide whether a change is acceptable.

Argos intentionally does not.

**AI compensates for flakiness.  
Argos removes it.**

AI-based approaches often:

- Hide small changes without clear explanations
- Mask rendering inconsistencies
- Create ambiguity between what changed and what was approved

Over time this leads to silent regressions and declining trust in the test suite.

## Flakiness is a signal

A flaky visual test usually points to an underlying problem, such as:

- Non deterministic animations
- Time-dependent rendering
- Uncontrolled fonts
- Async layout shifts
- Environment-specific rendering differences

Argos treats flakiness as **technical debt to fix**, not noise to ignore.

## Flaky management and resolution

Argos provides explicit tools to identify and resolve flakiness:

- Flaky indicators and reports
- Ignore changes on specific screenshots
- SDK-level stabilization for fonts, animations, images, and loading states
- [Helpers](/argos-helpers) to mask specific regions or elements

Learn more in [managing flaky tests](/about-flaky).

## Determinism over probability

Pixel diffing offers properties that matter in CI:

- **Deterministic**: same input, same result
- **Explainable**: exact pixels that changed are visible
- **Review-friendly**: reviewers assess facts, not model guesses
- **Auditable**: approvals have a clear meaning

AI introduces probability and hidden heuristics, which is a poor fit for regression testing.

## Built for long-term health

Argos optimizes for:

- Trust in failures
- High signal to noise ratio
- Stable baselines
- Predictable reviews

The result is visual testing teams rely on every day, not something they mute after a few weeks.

## Open by design

The diff engine and its surrounding logic are open source:

- No black box
- No hidden thresholds
- Fully inspectable and debuggable

Visual testing should be infrastructure, not magic.

---

// File: learn/fundamentals/baseline-build

import { RunPkgCommand } from "@site/src/partials";
import projectBranchesSettings from "./baseline-build/project-branches-settings.png";

# Baseline build

Argos compares screenshots to a chosen **baseline build**, determined by analyzing the commit history of your Git project.

:::note

This documentation covers Argos' Continuous Integration (CI) mode. For Monitoring mode, refer to the [Monitoring documentation](/build-modes#monitoring-mode).

:::

## What is a baseline build?

A **baseline build** serves as the reference point for comparing screenshots to detect visual changes. Each new build is compared against its corresponding baseline build.

## How does Argos determine the baseline build?

Argos selects the baseline build by finding the most recent **candidate build** that meets all of the following conditions:

1. Has the same build name as the triggered build
2. All framework tests passed
3. Build is not marked as [_subset_](/subset-builds)
4. Be auto-approved, manually approved or orphan
5. Its commit is an ancestor of the merge base between the triggered build's commit and the baseline branch

## What is the baseline branch?

The **baseline branch** is the branch Argos uses as the reference for determining the baseline build:

- For pull request builds, the base branch of the pull request is used.
- For push events, Argos uses the default baseline branch configured in your project.

:::note

By default, the repository's default branch is used as the baseline branch. You can modify this in the Argos project settings.

:::

## Auto-approved branches

Argos supports **auto-approved branches**, where branches matching specified patterns (e.g., `main`, `master`, or `develop`) are automatically approved for comparison.

:::note

By default, Argos auto-approves your default baseline branch. You can configure auto-approved branches in the Argos project settings.

:::

## Configuring branches in project settings

In the project settings, you can configure both the default baseline branch and any auto-approved branches.

<img
  src={projectBranchesSettings}
  alt="Project branches settings"
  className="rounded"
/>

## Choose a custom baseline build via SDK

Argos SDKs allow you to specify a custom baseline build if needed. This can be done using environment variables:

- `ARGOS_REFERENCE_BRANCH`: The branch name used as the custom baseline.
- `ARGOS_REFERENCE_COMMIT`: The commit hash used to select a specific baseline build.

## Orphan builds

An **orphan build** occurs when Argos has no prior screenshots to compare against. This is expected for a project's first builds; subsequent builds will establish a baseline automatically once approved.

---

// File: learn/fundamentals/monitoring-mode

import { RunPkgCommand } from "@site/src/partials";

# Build modes

Argos provides two build modes for visual testing: **Continuous Integration (CI) mode** and **Monitoring mode**. This page explains how each mode works, their key differences, and when to use them to best fit your workflow.

## Continuous Integration Mode

Continuous Integration (CI) mode is the default in Argos. It is designed to review the visual changes introduced by a feature branch and prevent regressions.

During your CI pipeline, screenshots of the application are captured on each pull request and on the default branch (main, production, etc.). These screenshots are uploaded to Argos, where they are compared against a [baseline build](/baseline-build).

The [baseline build](/baseline-build) represents the most recent approved state of your application and is automatically selected based on Git history analysis and [other criteria](/baseline-build).

In the Argos app, you can review highlighted differences, approve intended updates, and block regressions before merging.

**Note:** Your CI pipeline must also run on the default branch (main, production, etc.) to keep the baseline build up to date.

### Workflow

1. **Feature Development**
   - A developer creates a feature (or bugfix) branch and commits changes.
   - Optionally, a pull request (PR) is opened.

2. **Visual Tests in CI**
   - During these tests, your test framework (Playwright, Cypress, etc.) captures screenshots of the app. Argos offers [SDKs](/getting-started) for easy integration with popular frameworks.
   - At the end of the tests, screenshots are uploaded to Argos automatically with the SDK, or manually using the Argos CLI.

3. **Comparison with Baseline**
   - Argos receives the build containing screenshots and metadata.
   - It automatically determines the [baseline build](/baseline-build) using Git history analysis and other criteria.
   - The new screenshots are compared against the baseline.

4. **Results & Notifications**
   - The build is complete once all screenshots have been compared:
     - âœ… No differences â†’ commit status set to _success_.
     - âŒ Differences found â†’ commit status set to _failed_. The changes are visible in the Argos app for review and approval.
   - Argos notifies the Git providers (GitHub, GitLab, etc.) about the build status.
   - On GitHub, Argos also posts a summary comment with a link to the dashboard.
   - On Git providers, if branch protection rules require Argos checks to pass, pull requests will be blocked from merging until all visual changes are reviewed and approved in Argos.

5. **Approval Process**
   - The team reviews the changes in the Argos app:
     - Each screenshot change can be approved or rejected.
     - The build as a whole must then be approved or rejected. The check status on Git providers (GitHub, GitLab, etc.) is automatically updated accordingly.

```mermaid
graph TD;
  A[Code Commit & optional PR] --> B[CI runs visual tests with Argos];
  B --> C[Screenshots uploaded & compared to Baseline Build];
  C --> D[Results & Notifications];
  D --> E[Team reviews in Argos app];
  E -->|Approved| F[Merged to main/reference branch];
  E -->|Changes Requested| G[Fix Issues & Retest];
  F --> H[New Baseline established for future comparisons];
```

### Notifications

In CI mode, Argos integrates directly with your Git provider to surface results where developers work:

- **Commit status updates**: Each build sets the commit status to âœ… success or âŒ failed.
- **Pull request comments**: On GitHub, Argos posts a summary comment with a link to the Argos dashboard.
- **Slack notifications**: Enable [Slack notifications](/slack) to alert your team immediately when visual differences are detected.

### Use Cases

CI mode is designed to be the primary workflow for preventing regressions during development. Common scenarios include:

#### 1. Pull Request Validation

- **When:** A developer opens a PR with UI changes.
- **How:** Argos runs during CI, compares screenshots with the baseline, and blocks merging until visual changes are reviewed and approved.

#### 2. Default Branch Verification

- **When:** Code is merged into the main/reference branch.
- **How:** Argos runs on the default branch to ensure the new baseline is validated and ready for future comparisons.

#### 3. Continuous Feedback Loop

- **When:** Teams want fast feedback on every commit.
- **How:** CI mode surfaces results directly in GitHub, ensuring regressions are caught early in the workflow.

### Usage

CI mode is enabled by default.

Follow the [Get Started guide](/getting-started) to integrate Argos into your CI pipeline.

## Monitoring Mode

Monitoring mode is an **opt-in feature** in Argos. It is designed to track visual changes outside the standard CI flow, either on a schedule or before a release.

In this mode, your tests capture screenshots on the chosen branch (e.g., main or a release branch). The screenshots are uploaded to Argos and compared only against the **latest approved build**. Git history is ignored. The approval status alone defines the baseline.

### Workflow

1. **Enable Monitoring Mode**

- Activate monitoring for periodic checks or pre-release validation.

2. **Run Periodic Visual Tests**

- Your tests capture screenshots on the target branch (daily, weekly, or before a release).

3. **Compare with Latest Approved Build**

- Screenshots are compared only with the most recently approved build.

4. **Notify on Differences**

- If differences are found, notifications are sent.
- Changes must then be reviewed, approved, or corrected.

```mermaid
graph TD;
    A[Enable Monitoring Mode] --> B[Periodic Visual Test];
    B --> C[Compare with Latest Approved Build];
    C --> D[Notify on Differences];
    D -->|No Differences| E[Continue Monitoring];
    D -->|Differences Found| F[Review & Approval];
    F -->|Approved| G[Update Latest Approved Build];
    F -->|Not Approved| H[Fix & Retest];
```

### Notifications

[Set up **Slack notifications**](/slack#set-up-slack-notifications) to be alerted immediately when visual differences are detected, so your team can review and act quickly.

### Use Cases

Monitoring mode is useful when you need oversight beyond standard CI/CD pipelines:

#### 1. Regular Health Checks

- **When:** Your project changes frequently (content or style tweaks) but running CI on every change isn't practical.
- **How:** Schedule monitoring on the main branch (e.g., daily/weekly) to catch unexpected changes early.

#### 2. Pre-release Validation

- **When:** Before a major release, you need to confirm no regressions slipped in.
- **How:** Run monitoring on the release branch and compare with the last approved build before deployment.

#### 3. Post-deployment Monitoring

- **When:** After staging or production deployments, you want to detect environment-specific visual issues.
- **How:** Run monitoring after each deployment to catch discrepancies not visible in development.

#### 4. Third-party Integrations

- **When:** Your app depends on external widgets or services that can change independently.
- **How:** Use monitoring to ensure third-party visuals remain stable over time.

### Usage

Enable Monitoring mode by setting `mode: "monitoring"` in your SDK configuration.

**CLI**

<RunPkgCommand
  command={["argos upload --mode=monitoring components ./screenshots"]}
/>

**Playwright**

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";

export default defineConfig({
  reporter: [
    process.env.CI ? ["dot"] : ["list"],
    [
      "@argos-ci/playwright/reporter",
      {
        uploadToArgos: !!process.env.CI,
        token: "<YOUR-ARGOS-TOKEN>",
        // highlight-next-line
        mode: "monitoring",
      },
    ],
  ],
});
```

**Cypress**

```js cypress.config.js
const { defineConfig } = require("cypress");
const { registerArgosTask } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  e2e: {
    async setupNodeEvents(on, config) {
      registerArgosTask(on, config, {
        uploadToArgos: !!process.env.CI,
        token: "<YOUR-ARGOS-TOKEN>",
        // highlight-next-line
        mode: "monitoring",
      });
    },
  },
});
```

---

// File: learn/guides/ci-pipelines/build-splitting

import { RunPkgCommand } from "@site/src/partials";

# Monorepos setup

Optimize visual testing in monorepos with Argos: Use build splitting to manage distinct tests for components and E2E, ensuring precise feedback.

Monorepos, containing multiple packages or applications, can greatly benefit from Argos's build splitting feature. This allows for distinct visual testing builds within the same commit, catering to diverse screenshot categories such as component libraries and end-to-end (E2E) tests.

## Leveraging Build Splitting in Monorepos

Argos supports build splitting across all SDKs, offering a streamlined approach to manage visual tests for different parts of your monorepo. By specifying a unique build name for each category of screenshots, you can isolate and target tests more effectively.

## Practical Application

Imagine your monorepo includes both a component library and an application undergoing E2E testing. You can differentiate these test suites in Argos by assigning a unique `build-name` to each, ensuring clear separation and organization of visual tests. This is achieved by setting the `buildName` option in your Argos integration, as shown in the examples below for both component screenshots and E2E tests:

**For components:**

<RunPkgCommand
  command={["argos upload --build-name components ./screenshots/components"]}
/>

**For E2E tests with Playwright:**

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";

export default defineConfig({
  reporter: [
    process.env.CI ? ["dot"] : ["list"],
    [
      "@argos-ci/playwright/reporter",
      {
        uploadToArgos: !!process.env.CI,
        token: "<YOUR-ARGOS-TOKEN>",
        // highlight-next-line
        buildName: "e2e",
      },
    ],
  ],
  // Other config
});
```

This approach not only enhances the clarity of your visual testing efforts in a monorepo context but also improves the efficiency of identifying and addressing potential visual regressions across different scopes of your project.

---

// File: learn/guides/ci-pipelines/parallel-testing

# Parallel testing (sharding)

Boost test suite efficiency with Argos Parallel Testing: Automate and streamline concurrent test executions across multiple environments effortlessly.

## Playwright

Argos seamlessly integrates with Playwright, offering out-of-the-box support for [Playwright tests sharding](https://playwright.dev/docs/test-sharding). This means zero configuration hassle for you. For more details, refer to the [Argos Playwright SDK](/playwright).

If you use an advanced orchestration system like the excellent one from [Currents](https://currents.dev), use `argos finalize`.

## Other SDKs

For environments beyond Playwright, Argos facilitates sharding through two key environment variables, simplifying the setup:

- `ARGOS_PARALLEL`: Activate the parallel mode.
- `ARGOS_PARALLEL_TOTAL`: Specifies the number of parallel nodes. It's crucial to ensure equal calls to Argos upload across these nodes.
- `ARGOS_PARALLEL_INDEX`: Specifies the index of the current parallel node. Must start from `1`.
- `ARGOS_PARALLEL_NONCE`: A unique identifier for each build. In most CI environments, Argos will automatically generate this for you.

:::note

Alternatively, use `--parallel`, `--parallel-nonce`, `--parallel-total` and `--parallel-index` flags with the CLI or `parallel: { nonce: string, total: number, index: number }` within SDK options.

:::

## Modes

There is two parallel modes available:

- If `ARGOS_PARALLEL_TOTAL` is set to a `number`, Argos will wait for this number of upload before finalizing the build.
- If `ARGOS_PARALLEL_TOTAL` is set to `-1`, Argos will wait for a `argos finalize` call to finalize the build.

### Implementing in GitHub Actions

#### With a known number of shards

Below is a practical example showcasing how to configure Argos sharding within a GitHub Actions workflow.

```yml title=".github/workflows/ci.yml"
jobs:
  e2e-tests:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2, 3, 4]
        shardTotal: [4]
    steps:
      # ---
      # Here you setup your repo and run your E2E tests
      # ---
      - name: Upload screenshots to Argos
        env:
          ARGOS_PARALLEL: true
          ARGOS_PARALLEL_TOTAL: ${{ matrix.shardTotal }}
          ARGOS_PARALLEL_INDEX: ${{ matrix.shardIndex }}
          # ARGOS_PARALLEL_NONCE is automatically detected

        run: npm exec -- argos upload ./screenshots
```

#### With a finalize call

Below is a practical example showcasing how to configure Argos sharding within a GitHub Actions workflow.

```yml title=".github/workflows/ci.yml"
jobs:
  e2e-tests:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2, 3, 4]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      # ---
      # Here you setup your repo and run your E2E tests
      # ---
      - name: Upload screenshots to Argos
        env:
          ARGOS_PARALLEL: true
          ARGOS_PARALLEL_TOTAL: -1
          ARGOS_PARALLEL_INDEX: ${{ matrix.shardIndex }}
          # ARGOS_PARALLEL_NONCE is automatically detected

        run: npm exec -- argos upload ./screenshots

  finalize:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    # Finalize the build even if some shards have failed
    if: ${{ always() }}
    needs: ["e2e-tests"]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - name: Finalize argos build
        env:
          # ARGOS_PARALLEL_NONCE is automatically detected

        run: npm exec -- argos finalize
```

---

// File: learn/guides/ci-pipelines/run-on-preview-deployment

# Run on preview deployments

Catch visual regressions **before merging** by running automated tests on every preview deployment.

Argos integrates with GitHub Actions and connects seamlessly with providers like **Vercel, Netlify, and Cloudflare**.

With this setup:

- Each deployment preview is tested automatically
- Regressions are surfaced directly in your pull requests
- Your production baseline stays reliable and up to date

## Setup with Vercel repository dispatch events

Vercel can notify GitHub on every deployment via a [`repository_dispatch` event](https://vercel.com/docs/git/vercel-for-github#repository-dispatch-events).

Argos can use this payload to run visual tests against the preview URL.

```yaml title=".github/workflows/ci.yml"
name: Playwright + Argos Tests

on:
  repository_dispatch:
    types:
      - "vercel.deployment.success"

permissions:
  contents: read
  # Required to access pull request metadata for Argos with GITHUB_TOKEN
  pull-requests: read

jobs:
  run-e2es:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4

      - name: Install dependencies
        run: npm ci && npx playwright install --with-deps

      - name: Print context for debugging optional
        run: |
          echo "URL: $BASE_URL"

      - name: Run Playwright tests with Argos reporter
        run: npx playwright test
        env:
          # URL of the preview deployment used by your test as the base URL.
          BASE_URL: ${{ github.event.client_payload.deployment.url }}
          # Provided by GitHub used by Argos to link builds to branches and pull requests
          # Optional, if not provided Argos will not link builds to PRs
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## Setup with GitHub deployment status events

If your hosting provider emits GitHub Deployments events Vercel, Netlify, Cloudflare, you can trigger tests from the [`deployment_status` event](https://docs.github.com/en/webhooks/webhook-events-and-payloads#deployment_status).

The event carries the preview URL when a deployment becomes successful.

```yaml title=".github/workflows/ci.yml"
name: Playwright + Argos Tests

on:
  deployment_status:

permissions:
  contents: read
  # Required to access pull request metadata for Argos with GITHUB_TOKEN
  pull-requests: read

jobs:
  run-e2es:
    # Run tests only if the deployment is successful
    if: github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success'

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4

      - name: Install dependencies
        run: npm ci && npx playwright install --with-deps

      - name: Print context for debugging optional
        run: |
          echo "URL: $BASE_URL"
          echo "Branch: $ARGOS_BRANCH"

      - name: Run Playwright tests with Argos reporter recommended
        run: npx playwright test
        env:
          # URL of the preview deployment used by your test as the base URL.
          BASE_URL: ${{ github.event.client_payload.deployment.url }}
          # Set only for production deployments to ensure stable baselines usually `main`.
          ARGOS_BRANCH: ${{ github.event.client_payload.deployment.meta.production && 'main' || '' }}
          # Provided by GitHub used by Argos to link builds to branches and pull requests
          # Optional, if not provided Argos will not link builds to PRs
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## Disable the Vercel Toolbar

By default, Vercel may inject a toolbar overlay into preview deployments. This can interfere with automated screenshots.

To avoid false diffs, disable the toolbar in your tests by sending the [`x-vercel-skip-toolbar` header](https://vercel.com/docs/vercel-toolbar/managing-toolbar#disable-toolbar-for-automation) with every request.

### Playwright

Add the header in your `playwright.config.ts` so all test requests skip the toolbar:

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";

export default defineConfig({
  use: {
    extraHTTPHeaders: {
      "x-vercel-skip-toolbar": "1",
    },
  },
});
```

### Cypress

Inject the header for all network requests in your test suite:

```ts title="support/index.ts"
beforeEach(() => {
  cy.intercept(`${Cypress.config("baseUrl")}**`, (req) => {
    req.headers["x-vercel-skip-toolbar"] = "1";
  });
});
```

## Running without GITHUB_TOKEN

You can run Argos tests without exposing `GITHUB_TOKEN`. This is useful if you want to limit token scope in deployment workflows.

However, some features will not be available:

- Builds are only associated with a branch (no pull request metadata).
- No pull request link will appear in Argos.

:::note

Argos SDKs warn if `GITHUB_TOKEN` is missing. To silence this, set
`DISABLE_GITHUB_TOKEN_WARNING=true`.

:::

---

// File: learn/guides/ci-pipelines/skip-build

# Skipping a build

Sometimes you want Argos to report success without running visual tests.  
This is useful when Argos is configured as a required GitHub status check, but you intentionally want to skip screenshots for a commit or pull request.

A skipped build:

- uploads no screenshots
- runs no visual comparison
- immediately marks the commit status as success

## Creating a skipped build

You can skip a build in two ways.

### Environment variable

Set the environment variable `ARGOS_SKIPPED` to `"true"` in your CI configuration.

**GitHub Actions example:**

```yaml title=".github/workflows/ci.yml"
jobs:
  visual-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v6
      - name: Run tests
        run: npm run visual-tests # or your test command
        env:
          ARGOS_SKIPPED: "true"
```

This reports a successful Argos check without uploading screenshots.

### Using the CLI

You can also explicitly create a skipped build using the CLI.

```yaml title=".github/workflows/ci.yml"
jobs:
  visual-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v6
      - name: Skip Argos build
        run: npx @argos-ci/cli skip
```

This immediately creates a successful Argos build with no visual testing.

---

// File: learn/guides/ci-pipelines/subset-builds

import { RunPkgCommand } from "@site/src/partials";

# Subset builds

Subset builds are designed for CI runs that **don't execute the full E2E test suite** on a branch. When a build is marked as subset, Argos **ignores removed screenshots** and only notifies you about **changed and added screenshots** from the tests you did run.

This is helpful for speeding up feature-branch validation while still getting reliable visual feedback from the relevant tests.

:::note

You still need to run your full test suite on your main branch to create and update **baseline builds**. Subset builds are not eligible as baselines. See [Baseline build](/baseline-build).

:::

## Diagram flow

```mermaid
flowchart TB
  %% Subset builds vertical layout

  Start["CI run starts"]

  subgraph Main["Main branch"]
    direction TB
    M1["Run full E2E suite"]
    M2["Upload screenshots"]
    M3["Baseline build<br/>added Â· changed Â· removed"]
    M1 --> M2 --> M3
  end

  subgraph Feature["Feature branch"]
    direction TB
    F0["ARGOS_SUBSET=true<br/>or --subset"]
    F1["Run partial suite"]
    F2["Upload screenshots"]
    F3["Subset build notifications<br/>only changed and added screenshots"]
    F0 --> F1 --> F2 --> F3
  end

  Start --> Main
  Start --> Feature

  M3 -. "Compare against baseline" .-> F3
```

## Enable subset builds

You can enable subset builds in any Argos SDK or the CLI.

### Environment variable

Set the environment variable `ARGOS_SUBSET` to `"true"` in your CI configuration.

```yml title=".github/workflows/ci.yml"
steps:
  - name: Run tests
    run: npm test
    env:
      ARGOS_SUBSET: "true"
```

### CLI

Use the `--subset` flag with the CLI.

<RunPkgCommand command="argos upload --subset ./screenshots" />

### SDK option

Most SDKs expose a `subset` option on the upload configuration.

```js title="upload.js"
import { upload } from "@argos-ci/core";

await upload({
  root: "./screenshots",
  subset: true,
});
```

## Examples

### Node.js

```js title="scripts/argos-upload.js"
import { upload } from "@argos-ci/core";

await upload({
  root: "./screenshots",
  subset: true,
});
```

### Playwright

For Playwright, simply set `ARGOS_SUBSET=true` in your CI job. The reporter will mark the build as a subset build.

```yml title=".github/workflows/ci.yml"
steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-node@v4
  - run: npm ci
  - name: Run Playwright tests
    env:
      ARGOS_SUBSET: "true"
    run: npx playwright test
```

### Cypress

For Cypress, set `ARGOS_SUBSET=true` in your CI job that runs Cypress and uploads screenshots.

```yml title=".github/workflows/ci.yml"
steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-node@v4
  - run: npm ci
  - name: Run Cypress tests
    env:
      ARGOS_SUBSET: "true"
    run: npx cypress run
```

## Troubleshooting / FAQ

**Why are removed screenshots ignored?**  
Subset builds only include a portion of your test suite, so missing screenshots may simply be from skipped tests, not actual deletions. Ignoring removals avoids false positives.

**Why canâ€™t a subset build be a baseline?**  
Baselines must represent the full test suite. Subset builds are incomplete by design and would cause missing screenshots in comparisons.

---

// File: learn/guides/visual-coverage/injecting-css

# Injecting CSS

Enhance Argos screenshots with custom CSS: Perfect for addressing flaky tests or complex scenarios, ensuring your visual diffs are precise and reliable.

In addition to [built-in helpers](https://argos-ci.com/docs/argos-helpers#helpers), Argos offers the possibility to add custom CSS evaluated during the screenshot process. It can be helpful for complex use cases that produce flaky visual diffs.

## Add CSS while taking the screenshot

All our SDKs support an `argosCSS` option that allows you to specify custom CSS evaluated during the screenshot process. The style will be removed from the page after the screenshot is taken.

```ts
// Usage in Playwright or Puppeteer
await argosScreenshot(page, "my-screenshot", {
  argosCSS: `iframe { display: none; }`,
});

// Usage in Cypress
cy.argosScreenshot("my-screenshot", {
  argosCSS: `iframe { display: none; }`,
});
```

## Add CSS in your code

Argos adds a `__argos__` class to the HTML element during screenshots. You can target this class in your CSS for Argos-specific styling.

```css
.__argos__ iframe {
  display: none;
}
```

This feature enhances control over the visual testing environment, helping to manage complex scenarios or resolve flaky visual differences.

---

// File: learn/guides/visual-coverage/screenshot-metadata

# Adding Screenshot metadata

Enrich your screenshots in Argos with metadata by adding a companion JSON file. This metadata appears on the build page and helps contextualize how and why a screenshot was generated.

## How It Works

For each screenshot file, you can create a metadata file with the same name and the `.argos.json` suffix:

```
myscreenshot.png
myscreenshot.png.argos.json
```

The `.argos.json` file must be valid JSON following the Argos metadata schema.

:::note

If you use an official Argos SDK like `@argos-ci/playwright`, `@argos-ci/cypress`, `@argos-ci/puppeteer` or `@argos-ci/storybook`, the SDK automatically generates and uploads this metadata for you. If you don't use any SDK you may want to implement your own metadata generation and using `@argos-ci/core` or `@argos-ci/cli`.

:::

## Schema Autocomplete

To enable autocompletion, type checking, and schema validation in editors like VS Code, you can add a `$schema` field at the top of your `.argos.json` file:

```json
{
  "$schema": "https://api.argos-ci.com/v2/screenshot-metadata.json"
}
```

## Top-Level Fields

| Field               | Type                                      | Description                                                                            |
| ------------------- | ----------------------------------------- | -------------------------------------------------------------------------------------- |
| `$schema`           | `string?`                                 | Ignored. Can be set to get completions, validations and documentation in some editors. |
| `url`               | `string?`                                 | The URL of the page that was screenshotted.                                            |
| `previewUrl`        | `string?`                                 | A URL to an accessible preview of the screenshot.                                      |
| `viewport`          | [Viewport](#viewport)?                    | The viewport dimensions when the screenshot was taken.                                 |
| `colorScheme`       | `"light" \| "dark" `                      | The color scheme when the screenshot was taken.                                        |
| `mediaType`         | `"screen" \| "print" `                    | The media type when the screenshot was taken.                                          |
| `test`              | [Test](#test)?                            | Information about the test that generated the screenshot.                              |
| `browser`           | [Browser](#browser)?                      | The browser that generated the screenshot.                                             |
| `automationLibrary` | [Automation Library](#automation-library) | The automation library that generated the screenshot. _(Required)_                     |
| `sdk`               | [SDK](#sdk)                               | The Argos SDK that generated the screenshot. _(Required)_                              |

## Viewport

```json
{
  "width": 1280,
  "height": 720
}
```

- `width` (number): Width of the viewport.
- `height` (number): Height of the viewport.

## Test

```json
{
  "id": "test-id",
  "title": "should render homepage correctly",
  "titlePath": ["E2E", "Homepage"],
  "retries": 1,
  "retry": 0,
  "repeat": 0,
  "location": { "file": "tests/homepage.spec.ts", "line": 42, "column": 3 },
  "annotations": [
    {
      "type": "slow",
      "description": "Known performance issue",
      "location": { "file": "tests/homepage.spec.ts", "line": 40, "column": 1 }
    }
  ]
}
```

- `id` (string?): The unique identifier of the test.
- `title` (string): The title of the test.
- `titlePath` (string[]): The hierarchy of titles leading to the test.
- `retries` (number?): Number of retries for the test.
- `retry` (number?): The current retry count.
- `repeat` (number?): The repeat count for the test.
- `location` ([Location](#location)?): Where the test is located in the source code.
- `annotations` ([Test Annotation](#test-annotation)[]?): Extra information about the test.

## Location

```json
{
  "file": "src/components/Button.tsx",
  "line": 10,
  "column": 5
}
```

- `file` (string): The source file.
- `line` (number): The line number.
- `column` (number): The column number.

## Test Annotation

```json
{
  "type": "skip",
  "description": "Flaky test",
  "location": { "file": "tests/button.spec.ts", "line": 12, "column": 1 }
}
```

- `type` (string): Type of annotation.
- `description` (string?): Optional explanation.
- `location` ([Location](#location)?): Where the annotation is located in the source code.

## Browser

```json
{
  "name": "chromium",
  "version": "112.0.0"
}
```

- `name` (string): Browser name.
- `version` (string): Browser version.

## Automation Library

```json
{
  "name": "playwright",
  "version": "1.45.0"
}
```

- `name` (string): The name of the automation library (e.g. `playwright`, `cypress`).
- `version` (string): The version of the automation library.

## SDK

```json
{
  "name": "@argos-ci/playwright",
  "version": "2.0.0"
}
```

- `name` (string): The name of the Argos SDK.
- `version` (string): The version of the Argos SDK.

## Complete Example

Hereâ€™s a full example of `myscreenshot.png.argos.json`:

```json
{
  "url": "https://example.com/home",
  "viewport": { "width": 1280, "height": 720 },
  "colorScheme": "light",
  "mediaType": "screen",
  "test": {
    "title": "renders homepage correctly",
    "titlePath": ["E2E", "Homepage"],
    "location": { "file": "tests/homepage.spec.ts", "line": 42, "column": 3 }
  },
  "browser": { "name": "chromium", "version": "112.0.0" },
  "automationLibrary": { "name": "playwright", "version": "1.45.0" },
  "sdk": { "name": "@argos-ci/playwright", "version": "2.0.0" }
}
```

## Notes

- Fields marked as **required** must be included.
- Unknown fields are ignored.
- Each screenshot can have its own metadata file.

---

// File: learn/guides/visual-coverage/screenshot-pages-script

# Capture Screenshots from URLs

Efficiently capture web page screenshots across frameworks with Argos: A step-by-step guide for Playwright, Cypress, and Puppeteer integration.

## Using Playwright

Below is a step-by-step script for Playwright to take screenshots of specified pages. This script utilizes the Argos Playwright integration for streamlined screenshot capture:

```js title="screenshot-pages.spec.ts"
import { test } from "@playwright/test";
import { argosScreenshot } from "@argos-ci/playwright";

const pages = [
  { name: "homepage", path: "/" },
  { name: "integrations", path: "/integrations" },
  { name: "contact", path: "/contact-us" },
  { name: "pricing", path: "/pricing" },
];

for (const { name, path } of pages) {
  test(`Run Argos on ${name} (${path})`, async ({ page }) => {
    await page.goto(path);
    await argosScreenshot(page, name);
  });
}
```

## Using Cypress

Here's how you can capture screenshots within Cypress. The script navigates to each page and uses the Argos Cypress command for screenshots:

```js title="screenshot-pages.spec.ts"
const pages = [
  { name: "homepage", path: "/" },
  { name: "integrations", path: "/integrations" },
  { name: "contact", path: "/contact-us" },
  { name: "pricing", path: "/pricing" },
];

for (const { name, path } of pages) {
  it(`Run Argos on ${name} (${path})`, () => {
    cy.visit(path);
    cy.argosScreenshot(name);
  });
}
```

## Using Puppeteer

or Puppeteer users, this script demonstrates how to capture page screenshots effectively. It employs Puppeteer for navigation and screenshot capture:

```js title="screenshot-pages.spec.ts"
import puppeteer from "puppeteer";
import { argosScreenshot } from "@argos-ci/puppeteer";

const baseUrl = "http://localhost:3000";
const pages = [
  { name: "homepage", path: "/" },
  { name: "integrations", path: "/integrations" },
  { name: "contact", path: "/contact-us" },
  { name: "pricing", path: "/pricing" },
];

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  for (const { name, path } of pages) {
    await page.goto(`${baseUrl}${path}`);
    await page.screenshot({ path: `${name}.png` });
  }

  await browser.close();
})();
```

---

// File: learn/guides/visual-coverage/storybook-story-modes

# Storybook story modes for testing themes, viewports, and locales

Argos can capture multiple versions of your stories by applying different â€œmodes,â€ which are essentially combinations of global Storybook settings (such as theme, viewport, locale, etc.). With modes, you can automatically generate a separate snapshot for each unique configuration.

:::note

If you already have `parameters.chromatic.modes`, Argos will handle those settings by default. Prefer `parameters.argos.modes` in new work.

:::

## What are modes?

A mode is a preset that configures various Storybook globals. For instance, you can have a â€œdarkâ€ mode for your UI theme, a â€œmobileâ€ mode for smaller screens, or a combined â€œdark-mobile-spanishâ€ mode that configures multiple globals at once.

**Key features of modes:**

- Each mode is named (e.g., "dark desktop" or "mobile").
- Each mode sets specific values for the Storybook globals (e.g., viewport size, background color, locale).
- Argos creates a separate visual baseline for each mode name.

## Setting up globals & addons

Before you define any modes, make sure youâ€™ve configured the relevant Storybook addons in your `.storybook/preview.ts` (or `.js`) file. Examples include:

- [`@storybook/addon-viewport`](https://www.npmjs.com/package/@storybook/addon-viewport) for screen sizes
- [`@storybook/addon-themes`](https://www.npmjs.com/package/@storybook/addon-themes) for light/dark themes
- [`@storybook/addon-backgrounds`](https://www.npmjs.com/package/@storybook/addon-backgrounds) for backgrounds
- [`storybook-i18n`](https://www.npmjs.com/package/storybook-i18n) for locales

These addons utilize Storybook â€œglobalsâ€ and â€œdecoratorsâ€ under the hood. Argos modes simply manipulate those globals at test time to generate multiple snapshots of the same story.

```ts title=".storybook/preview.ts"
import { withThemeByClassName } from "@storybook/addon-themes";
import "../src/styles.css";

const preview = {
  parameters: {
    viewport: {
      viewports: {
        compact: {
          name: "Compact",
          styles: { width: "600px", height: "900px" },
        },
        widescreen: {
          name: "Widescreen",
          styles: { width: "1440px", height: "900px" },
        },
      },
    },
    backgrounds: {
      values: [
        { name: "Light", value: "#ffffff" },
        { name: "Dark", value: "#1A1A1A" },
      ],
    },
  },
  decorators: [
    withThemeByClassName({
      themes: {
        light: "light",
        dark: "dark",
      },
      defaultTheme: "light",
    }),
  ],
};

export default preview;
```

## Defining modes

Create a `.storybook/modes.ts` (or `.js`) file that exports an object where each key is a mode name and each value is a set of overrides for the Storybook globals. For example:

```ts title=".storybook/modes.ts"
export const allModes = {
  dark: {
    backgrounds: { value: "#1A1A1A" },
    theme: "dark",
  },
  mobile: {
    viewport: "compact",
  },
  "dark widescreen": {
    backgrounds: { value: "#1A1A1A" },
    theme: "dark",
    viewport: "widescreen",
  },
  "light mobile": {
    backgrounds: { value: "#ffffff" },
    theme: "light",
    viewport: "compact",
  },
};
```

Each object can include as many or as few globals as you need. If a mode doesnâ€™t specify a particular global, that global simply wonâ€™t be changed in that mode.

## Applying modes

Attach modes to any level of your Storybook: globally in `.storybook/preview.ts` (or `.js`), at the component (default export) level, or in an individual storyâ€™s parameters. Argos merges all modes defined up the chain.

### Basic usage in a story file

```ts title="ProductCard.stories.ts"
// Replace your-framework with the framework you are using, e.g. react-vite, nextjs, nextjs-vite, etc.
import type { Meta, StoryObj } from "@storybook/your-framework";

import { ProductCard } from "./ProductCard";
import { allModes } from "../../../.storybook/modes";

const meta = {
  title: "Components/ProductCard",
  component: ProductCard,
  parameters: {
    // Use Argos for new projects; Chromatic is recognized too
    argos: {
      modes: {
        mobile: allModes.mobile,
        dark: allModes.dark,
      },
    },
  },
} satisfies Meta<typeof ProductCard>;

export default meta;
type Story = StoryObj<typeof meta>;

export const DefaultView: Story = {
  args: {
    productName: "Coffee Beans",
    price: 9.99,
  },
};

export const SoldOutView: Story = {
  args: {
    productName: "Coffee Beans",
    price: 9.99,
    isSoldOut: true,
  },
};
```

In this example, Argos will generate two snapshots for each story (DefaultView and SoldOutView): one in â€œmobileâ€ mode and another in â€œdarkâ€ mode.

## Combining modes from multiple levels

You can add modes in your `.storybook/preview.ts` (or `.js`) at the project level, then define additional modes in a story file. Argos â€œstacksâ€ these modes, creating a snapshot for every combination.

### Project-level modes

```ts title=".storybook/modes.ts"
import { allModes } from "./modes";

const preview = {
  parameters: {
    argos: {
      modes: {
        "light mobile": allModes["light mobile"],
      },
    },
  },
};

export default preview;
```

### Component-level modes

```ts title="ProductCard.stories.ts"
// Replace your-framework with the framework you are using, e.g. react-vite, nextjs, nextjs-vite, etc.
import type { Meta, StoryObj } from "@storybook/your-framework";
import { ProductCard } from "./ProductCard";
import { allModes } from "../../../.storybook/modes";

const meta = {
  title: "Components/ProductCard",
  component: ProductCard,
  parameters: {
    argos: {
      modes: {
        "dark widescreen": allModes["dark widescreen"],
      },
    },
  },
} satisfies Meta<typeof ProductCard>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Basic: Story = {
  args: {
    /* ... */
  },
};
```

When Argos runs, it will generate snapshots for each mode defined at the project level and the component level. So for Basic, you get â€œlight mobileâ€ (from `preview.ts`) plus â€œdark widescreenâ€ (from the componentâ€™s parameter).

## Excluding or disabling modes

Sometimes you want to turn off a certain higher-level mode for a specific story. You can do this by passing a disable property:

```ts title="ProductCard.stories.ts"
// ...

export const SpecialCard: Story = {
  args: {
    /* ... */
  },
  parameters: {
    argos: {
      modes: {
        "light mobile": { disable: true }, // turns off this inherited mode
      },
    },
  },
};
```

That story will now ignore light mobile mode but still apply any other inherited modes.

## Working with baselines

Each mode name corresponds to a separate baseline in Argos. If you rename a mode, itâ€™s treated as entirely new. If you alter the internals of a mode (like changing the viewport from â€œcompactâ€ to â€œultra-compactâ€) without renaming it, Argos still compares the new screenshot against the old baselines for that mode name.

:::note

If you have an original single baseline from before you introduced modes, and you want to keep it around, just add a mode like "baseline" that reproduces the same environment as the original story. That way, your old baseline is preserved while you experiment with new modes.

:::

## FAQ

<details>
  <summary>
    Can modes be applied if I'm still using `parameters.chromatic`?
  </summary>

Yes. Argos reads your `chromatic.modes` settings if present. However,
for new users or updated setups, prefer using `argos.modes` to avoid
any confusion in the future.

</details>

<details>
  <summary>Do all Storybook addons work with Argos modes?</summary>

Any addon that leverages Storybook globals should work, including [@storybook/addon-themes](https://storybook.js.org/addons/@storybook/addon-themes),
[@storybook/addon-viewport](https://storybook.js.org/addons/@storybook/addon-viewport),
[@storybook/addon-backgrounds](https://storybook.js.org/addons/@storybook/addon-backgrounds),
or [storybook-i18n](https://storybook.js.org/addons/storybook-i18n). Modes just
provide different values for those globals.

</details>

<details>
  <summary>What happens if I delete or rename a mode?</summary>

If you remove a mode from your code, Argos will stop capturing new snapshots for
that mode, and its baseline history wonâ€™t be updated anymore. Renaming a mode effectively
creates a new baseline, much like renaming a story.

</details>

Enjoy your multi-mode visual tests! By setting up modes for dark vs. light, mobile vs. desktop, and everything in between, you can verify all key variants of your UI without writing extra stories.

---

// File: learn/guides/visual-coverage/viewports

# Responsive viewports

Argos lets you capture the same page at multiple breakpoints with a single test. Configure viewports once and get consistent responsive coverage across Playwright, Cypress and Puppeteer.

## Prerequisites

This feature works seamlessly with [Playwright](/playwright), [Cypress](/cypress) and [Puppeteer](/puppeteer).

:::note

If you use Storybook, see the dedicated guide on [Storybook modes](/storybook-story-modes).

:::

## Viewport Configuration

Pass a viewports array to `argosScreenshot()` to generate screenshots for each dimension or preset you define. You can mix explicit sizes and device presets.

```js
await argosScreenshot(..., {
  viewports: [
    "iphone-4",
    { width: 800, height: 600 },
    { preset: "ipad-2", orientation: "landscape" },
  ],
});
```

## Available Presets

| Preset            | Width (px) | Height (px) |
| ----------------- | ---------- | ----------- |
| pro-display       | 3008       | 1962        |
| studio-display    | 2560       | 1440        |
| imac-24           | 2240       | 1260        |
| macbook-16        | 1536       | 960         |
| macbook-15        | 1440       | 900         |
| macbook-13        | 1280       | 800         |
| macbook-11        | 1366       | 768         |
| ipad-12-pro       | 1024       | 1366        |
| ipad-11-pro       | 834        | 1194        |
| ipad-10           | 810        | 1080        |
| ipad-10-pro       | 834        | 1112        |
| ipad-9-pro        | 768        | 1024        |
| ipad-2            | 768        | 1024        |
| ipad-mini         | 768        | 1024        |
| iphone-air        | 420        | 912         |
| iphone-17         | 402        | 874         |
| iphone-17-pro     | 402        | 873         |
| iphone-17-pro-max | 440        | 956         |
| iphone-16         | 393        | 852         |
| iphone-16e        | 390        | 844         |
| iphone-16-plus    | 430        | 932         |
| iphone-16-pro     | 402        | 874         |
| iphone-16-pro-max | 440        | 956         |
| iphone-15         | 393        | 852         |
| iphone-15-plus    | 430        | 932         |
| iphone-15-pro     | 393        | 852         |
| iphone-15-pro-max | 430        | 932         |
| iphone-14         | 390        | 844         |
| iphone-14-plus    | 428        | 926         |
| iphone-14-pro     | 393        | 852         |
| iphone-14-pro-max | 490        | 932         |
| iphone-13         | 390        | 844         |
| iphone-13-mini    | 360        | 780         |
| iphone-13-pro     | 390        | 844         |
| iphone-13-pro-max | 428        | 926         |
| iphone-12         | 390        | 844         |
| iphone-12-mini    | 360        | 780         |
| iphone-12-pro     | 390        | 844         |
| iphone-12-pro-max | 428        | 926         |
| iphone-11         | 414        | 896         |
| iphone-11-pro     | 375        | 812         |
| iphone-11-pro-max | 414        | 896         |
| iphone-xr         | 414        | 896         |
| iphone-x          | 375        | 812         |
| iphone-6+         | 414        | 736         |
| iphone-se2        | 375        | 667         |
| iphone-8          | 375        | 667         |
| iphone-7          | 375        | 667         |
| iphone-6          | 375        | 667         |
| iphone-5          | 320        | 568         |
| iphone-4          | 320        | 480         |
| iphone-3          | 320        | 480         |
| samsung-s10       | 360        | 760         |
| samsung-note9     | 414        | 846         |

## Troubleshooting and Best Practices

Many sites compute layout at load time and will not adapt cleanly if the viewport changes later. If you notice issues, you may want to run your test suite entirely for each viewport instead of changing the viewport before taking each screenshot.

For example, in Playwright you can create a separate browser context for each viewport size.

```ts title="playrwight.config.ts"
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  projects: [
    {
      name: "chromium-mobile",
      use: {
        ...devices["Desktop Chrome"],
        channel: "chrome",
      },
    },
    {
      name: "chromium-mobile",
      use: {
        ...devices["Desktop Chrome"],
        channel: "chrome",
        viewport: { width: 402, height: 874 }, // iPhone 7 viewport
      },
    },
  ],
});
```

You can also run `page.setViewportSize()` before navigating to the page to ensure the layout is computed correctly.

```ts
await page.setViewportSize({
  width: 640,
  height: 480,
});
await page.goto("https://example.com");
```

---

// File: learn/integrations/index

# Integrations

Argos integrates with the most common source control platforms and collaboration tools.  
Each integration has its own dedicated setup guide.

## Source Control Platforms

- [GitHub](/github)
- [GitLab](/gitlab)
- [Bitbucket](/bitbucket)
- [Azure DevOps](/azure-devops)

## Notifications

- [Slack](/slack)

---

// File: learn/integrations/github

# GitHub Integration

Connect Argos to GitHub for automated visual testing on every pull request and merge queue run. Argos reads commit history to pick the right baseline build and reports results back to GitHub so you can ship with confidence.

## What Argos does on GitHub

- Add commit and pull request checks, so Argos results can block merges when required in GitHub.
- Post [pull request comments](/pull-request-comments) with the latest build results and links back to Argos.
- Analyze commit history to find the right merge base and select the correct [baseline build](/baseline-build) for visual comparisons.

## Why Argos needs repository access

Argos analyzes commit history to choose the right [baseline build](/baseline-build) and posts commit statuses or pull request comments. Granting repository access lets Argos read commits, find merge bases, and report build results back to GitHub.

## Choose your access level

- **Full access (recommended)** â€” Required for Merge Queue and baseline selection based on commit history.
- **Limited access (no content)** â€” Works for basic checks without reading repository content; Merge Queue is not supported. See [GitHub Integration without Content Permission](#github-integration-without-content-permission).

Use GitHub Connect to log in with your GitHub account, then install the Argos GitHub App to link repositories.

## Install the Argos GitHub App

Argos provides a dedicated GitHub App that connects directly to your repositories, enabling real-time visual testing feedback on pull requests.

1. Visit the [Argos app page on GitHub](https://github.com/apps/argos-ci)
2. Click on "Configure" and select the organization where you want to install Argos
3. Follow the prompts to complete the installation

### Import a GitHub repository to Argos

1. Sign in to Argos and click on "Create a new project"
2. Choose GitHub as your provider, then click "Import your repository"

### Update the Repositories Shared with Argos

1. Go to the [Argos app page on GitHub](https://github.com/apps/argos-ci) and click "Configure"
2. Select the organization where you want to manage repository access
3. Under "Repository access," choose "Only select repositories" and select the specific repositories you wish to share with Argos

![Required Argos status check in GitHub](./github/repository-access.jpg)

## Required GitHub App permissions

Argos needs the following permissions to operate:

- **Contents** â€” used to find a common commit ancestor between branches
- **Statuses** â€” used to add statuses to commits
- **Pull requests** â€” used to add comments in pull requests
- **Actions** â€” used to allow tokenless authentication

We take your security and privacy seriously. If you have any concerns or questions, please [contact us](https://argos-ci.com/contact).

## GitHub Merge Queue support

Argos supports GitHub Merge Queue when you use the full-access Argos GitHub App. Merge Queue relies on Argos reading commit history to compute merge bases and publish required checks, so the restricted â€œGitHub without content accessâ€ integration does not support it. When Argos runs inside the merge queue, it compares your queued change against the previously approved commit on the target branch to ensure only clean visual changes are merged.

### GitHub Actions setup for Merge Queue

Listen to both `pull_request` and `merge_group` events so Argos uploads run for PR reviews and for queued merges:

```yaml title=".github/workflows/ci.yml"
name: Visual tests

on:
  pull_request:
  merge_group:

jobs:
  argos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v6
      - run: npm ci
      - run: npm run test:e2e # Run E2E tests with Argos SDK integration
        env:
          ARGOS_TOKEN: ${{ secrets.ARGOS_TOKEN }} # Argos token stored in GitHub Secrets
```

## GitHub Integration without Content Permission

If you prefer to use Argos without granting full content access to your repositories, you can integrate via a more restricted setup. This mode does not support Merge Queue because Argos cannot read commit history.

### Setting Up Argos with Limited GitHub Access

1. From the dashboard, select your team from the scope selector.
2. Select the **Settings** tab and go to the **Integrations** section.
3. Scroll to "GitHub without content access".
4. Click **Install GitHub App**.

![GitHub without content access settings in Argos](./github/github-light-settings.jpg)

5. On GitHub, choose the specific repositories where you want to install the Argos app.

![Argos GitHub app without content access](./github/github-light-app.jpg)

6. Back in Argos, go to the **Projects** tab.
7. Click **Create a new project** at the top right.
8. Select **Continue with GitHub (no-content access)**.

![Argos GitHub app without content access](./github/create-project.jpg)

9. Choose the repository you want to connect.

## GitHub Enterprise

### GitHub Enterprise Cloud

GitHub Enterprise Cloud works out of the box. Follow the same GitHub App setup described aboveâ€”no extra configuration is needed in Argos.

### GitHub Enterprise Server (self-hosted)

Self-hosted GitHub Enterprise Server deployments are supported on the Argos Enterprise plan, which also includes SAML SSO and other advanced features. To upgrade to Enterprise, [contact sales](mailto:contact@argos-ci.com).

---

// File: learn/integrations/gitlab

# GitLab Integration

Enhance your GitLab workflow with Argos for streamlined visual testing, direct feedback on merge requests, and easy GitLab repository access.

## Why Argos needs repository access

Argos reads commit history to select the correct [baseline build](/baseline-build) and reports statuses back to GitLab. Connecting your repository ensures Argos can compare builds accurately and keep merge requests up to date.

## Advantages of GitLab Integration

- Log in effortlessly via GitLab
- Access to GitLab repositories
- Get Argos feedback on your pull requests.

## Connecting a GitLab Repository

By leveraging GitLab's Personal Access Token, Argos communicates via a dedicated GitLab Bot User. This setup ensures direct feedback on your pull requests.

#### 1. Generate a Personal Access Token in GitLab

- Go to [GitLab tokens settings](https://gitlab.com/-/profile/personal_access_tokens?name=argos2&scopes=api,read_user).
- Click "Add new token".
- Set an expiration date 12 months ahead (maximum allowed).
- Click "Create personal access token" and then copy the generated token.

![Generate a Personal Access Token in GitLab](@site/src/img/gitlab-create-token.png)

:::note

You can also use a [Project Access Token](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) if you want to restrict access to a single project. If you choose this option, be sure to use set the role of the token as **developer**.

:::

#### 2. Configure the Generated Token in Argos

1. From the dashboard, select your team or your personal account from the scope selector
2. Select the **Settings** tab and go to the **Integrations** section
3. Scroll to **GitLab** section
4. Enter the generated token and click **Save**

![Configure GitLab in Argos](@site/src/img/gitlab-configuration-argos.png)

#### 3. Link GitLab Project to Argos

1. From the dashboard, select your team or your personal account from the scope selector
2. Select the **Projects** tab
3. Click on **Create a new Project** at the top right
4. Select **Continue with GitLab**
5. Pick your GitLab organization and the desired repository, the new project should appear in your projects list

![Configure GitLab in Argos](@site/src/img/argos-create-new-project.png)

## Connecting a Argos project to a GitLab Repository

First, ensure the [GitLab Personal Access Token has been configured correctly](#connecting-a-gitlab-repository).

In Argos, navigate to "Project Settings" â†’ "Connect Git Repository" and select the desired GitLab repository for association.

## GitLab Self-Managed

GitLab Self-Managed deployments are supported on the Argos Enterprise plan. These setups often require tailored configuration alongside SAML SSO and other enterprise features. To discuss enabling GitLab Self-Managed, [contact sales](mailto:contact@argos-ci.com).

---

// File: learn/integrations/bitbucket

# Bitbucket Integration

## Bitbucket Cloud

We currently do not support Bitbucket Cloud. If you see value in a Bitbucket integration and are open to partnering with us in its development, please [contact us](mailto:contact@argos-ci.com).

## Bitbucket Server (Data Center)

We currently do not support Bitbucket Server / Data Center. If you would like to explore this integration with us, please [contact us](mailto:contact@argos-ci.com).

---

// File: learn/integrations/azure-devops

# Azure DevOps Integration

We currently do not support Azure DevOps.

If you see value in a Azure DevOps integration and are open to partnering with us in its development, please [contact us](mailto:contact@argos-ci.com).

---

// File: learn/integrations/slack

import slackNotification from "./slack/slack-notification-example.png";
import automationConditions from "./slack/automation-conditions.png";
import slackChannelId from "./slack/slack-channel-id.png";

# Slack Integration

Argos integrates with Slack to keep your team aligned on visual changes and reviews.  
It sends notifications and also unfurls Argos build URLs directly inside Slack.

:::note
Slack integration is available on Pro and Enterprise plans
:::

## What you get

- Automatic Slack notifications when builds are created, reviewed, approved, or rejected
- Rich previews when pasting an Argos build URL in Slack
- Fine grained control using Automations conditions

## Slack notifications

Use Automations to post messages in the right channels at the right time.

Typical signals you may want to route to Slack:

- A build is ready for review
- Changes are requested
- A build is auto approved on main
- Only failed or blocking builds

Notifications include build status, branch, author, and a direct link to the build.

<img
  src={slackNotification}
  alt="Slack notification sent by Argos"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>
_Example of a Slack notification sent by Argos_

## URL unfurling in Slack

When you paste an Argos build URL into Slack, Argos automatically unfurls it.

The preview includes:

- Build status and outcome
- Project and branch
- Direct shortcut to open the build in Argos

This works in messages, threads, and shared links, which makes reviews and handoffs easier without extra clicks.

## Set up Slack integration

Set up a Slack integration to unfurl Argos build URLs.

1. Verify that you have selected the correct team in the top, if not click the double arrow icon to select the right team.
2. Go to the teamâ€™s **Settings** tab.
3. Select the **Integrations** section.
4. Click on **Connect to Slack**.

## Set up Slack notifications

Set up a Slack notification rule using Argos automations.

1. Select a project in your Argos team.
2. Go to the **Automations** tab in your Argos project and click on **New Automation**.
3. Name your automation, e.g., "Notify Slack on build completion".
4. Under **WHEN**, select one or several events that will trigger the notification.
5. (Optional) Under **IF**, add conditions such as "Build type is check".

   <img
     src={automationConditions}
     alt="Automation conditions example"
     className="rounded"
     style={{ marginBottom: 30, marginTop: 0, paddingTop: 0, width: 600 }}
   />

6. Under **THEN**, choose the action **Send notification to Slack**.

   If this is your first time using Slack with Argos, click **Connect to Slack** and follow the connection flow.

7. Select the Slack channel and optionally provide the channel ID.

   <img
     src={slackChannelId}
     alt="Locate Slack channel ID"
     className="rounded"
     style={{ marginBottom: 30, marginTop: 0, paddingTop: 0, width: 600 }}
   />
   _Finding the ID of a Slack Channel_

8. Click **Send test notification** to verify the connection. A test message will be sent to the selected channel.
9. Click **Create Rule** to activate it.

## Troubleshooting and Tips

- Make sure the Argos app is authorized in your Slack workspace.
- For private channels, manually invite the bot with `/invite @Argos`.
- Only Argos team admins can configure Slack integrations.
- You can test notifications anytime using **Send test notification**.

Need help setting up Slack integration? Reach out via [Discord](https://argos-ci.com/discord) or [contact support](mailto:contact@argos-ci.com).

---

// File: learn/reliability/flaky-test-detection

import flakyIndicator from "./flaky-test-detection/flaky-indicator.png";
import testPageExample from "./flaky-test-detection/test-page-example.png";

# Flaky Test Detection

Argos flags unstable tests so you can decide with confidence. See a flaky badge next to every changed test and dive into detailed history and stability scores on a dedicated test page

<img
  src={flakyIndicator}
  alt="Flaky indicator next to a test change"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>
_Example of the flaky indicator in a build review_

## View flaky indicators in your build review

1. Open any build in Argos
2. Spot the flaky badge beside each changed test
3. Hover over the badge to see details about the test's stability

## Explore the test page

By clicking on the flaky badge, you will be taken to the test page where you can see the full history of the test and its stability score.

<img
  src={testPageExample}
  alt="Test page showing history and flaky score"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>
_A sample test page with history timeline and score_

On the test page you will find:

- Timeline of every change that affected the test
- Stability graph showing pass rate over time
- Calculated flaky score from zero up to one hundred
- List of changes happened to the test

Use this information to approve stable tests or flag flaky ones for fixes.

## Ignore changes

When reviewing a visual test result in Argos, you may encounter changes that are not relevant or are caused by flakiness. You can **ignore a specific change** directly from the UI.

From the build page or the test page, click on the "Ignore" button next to the change you want to ignore.

Once ignored, Argos will no longer notify you if this **exact same change** happens again in future builds. This lets you filter out noise while keeping future regressions detectable.

### Best Use Cases

- Flaky UI elements that appear/disappear randomly or render inconsistently.
- Non-deterministic image rendering (e.g. base64 previews, antialiasing issues).

---

// File: learn/reliability/tests-dashboard

import testsDashboard from "./tests-dashboard.png";

# Tests Dashboard

The Tests dashboard gives you a project-wide view of test stability. It lists all tests sorted by flakiness score so the most flaky tests show up first.

<img
  src={testsDashboard}
  alt="Tests dashboard showing a list of tests with flakiness metrics"
  className="rounded border"
  style={{ marginBottom: 20 }}
/>
_A project Tests dashboard with flakiness metrics_

## Open the dashboard

1. Open your project in Argos.
2. Click the **Tests** tab.

## How tests are ranked

Tests are sorted by **flakiness score** (descending). The tests at the top are the most flaky.

## Columns explained

- **Test**: The latest screenshot uploaded for the test, the test name, and the build name.
- **Last change**: The most recent change detected on an auto-approved build during the selected period.
- **Flakiness**: A score that summarizes how flaky a test is based on its stability and consistency.
- **Changes**: The number of changes detected for the test during the selected period.
- **Stability**: The ratio of changes to total reference builds. A lower stability rate means the test is more likely to be flaky.
- **Consistency**: The ratio of one-off changes to total changes. A lower consistency rate means the test is more likely to be flaky.

## Filter and time range

- Filter tests by **build name** to focus on a subset of runs.
- Choose a **time period** to control which changes and scores are included.

## Open a test page

Click any row to open the detailed test page and review history and stability details. See [Flaky Test Detection](/flaky-test-detection) for more information.

---

// File: learn/reliability/flaky-tests/index

# Flaky Tests

Navigate the challenge of flaky tests with Argos: Discover strategies to enhance test reliability and promote accessibility for a stable visual testing environment.

## Emphasis on Accessibility

At Argos, we advocate for accessibility-focused end-to-end testing. Enhancing accessibility not only supports users with disabilities but also strengthens test consistency.

## Common Causes

Flakiness often stems from:

- **Dynamic Content**: Flakiness due to content changes, like ads or user-generated content.
- **Asynchronous Loading**: Inconsistent element or style loading affecting visuals.
- **Rendering Differences**: Browser or device variations altering visual output.
- **External Dependencies**: Reliance on external systems causing variability.
- **Animations and Transitions**: Unhandled animations leading to different visual states.
- **Resolution and Scaling**: Screen resolution or scaling differences impacting visuals.

Solutions involve identifying and addressing these root causes.

## Policy

We don't offer a "flaky test ignore" option, aligning with our ethos that addressing issues is preferable to bypassing them.

---

// File: learn/reliability/flaky-tests/wait-for-load

# Wait for Loading

Master timing in visual tests with Argos: Use `aria-busy` to ensure screenshots are captured post full page load, enhancing accuracy and consistency.

## Usage

`argosScreenshot()` delays capturing screenshots until no elements with `aria-busy` are detected, ensuring full page load.

```jsx
<Loader aria-busy={true} />
```

**We recommend to apply `aria-busy` on your loader components be ensure that your page is fully loaded before a screenshot is taken.**

---

// File: learn/reliability/flaky-tests/dates

# Stabilize Date & Time

Mitigate UI flakiness with stable date & time in visual testing: Hide dynamic dates or freeze them for consistency using Argos's practical solutions.

## Hiding the Date

Using Argos helpers, you can choose to hide a date or a time by adding `data-visual-test="transparent"`.

```html
<time data-visual-test="transparent">10 oct, 2012</time>
```

## Freezing the Date

If you are using dates (not precise time), you can stabilize them in your seeds by running a script that updates dates just before running your E2E tests.

---

// File: learn/reliability/flaky-tests/glitches

# Browser Glitches

Eliminate browser-induced visual discrepancies: Ensure consistent environments and utilize Argos helpers to address properties like `border-radius` for glitch-free visual testing.

Glitches can occur when your tests are not running in the same environment. Be sure to run your E2E tests in the exact same environment (OS and Browser).

## Border Radius

Sometimes, the `border-radius` property can cause screenshots to appear differently across different browsers or devices.

To address this, you can add the `data-visual-test-no-radius` Argos helper to remove the border radius while taking screenshots.

```html
<button className="rounded" data-visual-test-no-radius>My button</button>
```

---

// File: learn/reliability/flaky-tests/argos-helpers

# Argos Helpers

Enhance your visual tests with Argos SDKs: Use `data-visual-test` attributes to manage dynamic content, ensuring consistent, flakiness-free screenshots.

## Helpers

For tailored visual testing, the `data-visual-test` attributes provide control over how elements appear in Argos screenshots. This can be especially useful for obscuring or modifying elements with dynamic content, like dates.

- `[data-visual-test="transparent"]`: Renders the element transparent (`visibility: hidden`).
- `[data-visual-test="removed"]`: Removes the element from view (`display: none`).
- `[data-visual-test="blackout"]`: Masks the element with a blackout effect (Storybook, Playwright, and Cypress SDK only).
- `[data-visual-test-no-radius]`: Strips the border radius from the element.

**Example: Using a helper attribute to hide a div from the captured screenshot:**

```html
<div id="clock" data-visual-test="transparent">...</div>
```

---

// File: learn/review-workflow/builds-list

import buildsList from "./builds-list.png";

# Builds list

The Builds list is the main view for tracking every Argos build in a project. It helps you scan status, drill into a specific build, and filter down to exactly the runs you care about.

<img
  src={buildsList}
  alt="Builds list showing build rows with status badges, change counts, and filters"
  className="rounded border"
  style={{ marginBottom: 20 }}
/>
_A project Builds list with status badges, change counts, and filters_

## Open the Builds list

1. Open your project in Argos.
2. Click the **Builds** tab.

## What each row shows

Each row represents a single build and typically includes:

- **Build ID** and status (for example: Auto-approved, Approved, Changes detected, or Rejected).
- **Change counts** for the build (changes, additions, and removals when applicable).
- **Pull request metadata** when the build is linked to a PR.
- **Branch and commit** information.
- **Timestamp** for when the build was created.

## Filters

Use the filters at the top of the page to narrow the list:

- **Type**: Filter by build category (for example: check, orphan, or auto-approved builds).
- **Status**: Filter by review state (for example: approved, changes detected, or rejected).
- **Build name**: Filter to a specific build name when your CI splits builds (see [Build splitting](/build-splitting)).

Build names in the filter are sourced from builds created in the **last month**. Builds can't be deleted, but unused build names drop out of the filter list after about a month of inactivity.

## FAQ

**Can I delete a build?**
No. Builds are immutable records and cannot be deleted.

**Why did a build name disappear from the filter?**
The build name list only includes names used in builds created within the last month. If a build name has no recent activity, it will no longer appear.

---

// File: learn/review-workflow/pull-request-comments

import githubPrComment from "@site/src/img/github-pr-comment.png";

# Pull request comments

Stay informed with Argos: Get build results directly in your GitHub pull requests for a streamlined review process and efficient change management.

## Overview

Every time there's an update to a build status, Argos automatically comment to the associated pull request thread. This comment contains the latest build status, together with a convenient link that leads you directly to the detailed build page on Argos.

<img
  src={githubPrComment}
  alt="Argos GitHub pull request comment"
  className="rounded"
  style={{ marginBottom: 20, width: 600 }}
/>

## Silence pull request comments

If you would like to stop automatic comments from appearing on your pull request by the Argos GitHub bot, you can silence them through the project Settings:

1. Go to your project Settings in Argos.
2. In the "Connected Git Repository" section, you will find a checkbox for "Enable pull request comments".
3. Uncheck this box to disable the feature and save the settings.

Once you uncheck the box, Argos will stop posting build status updates in your pull requests. You can always re-enable it by checking the box again.

---

// File: learn/review-workflow/summary-checks

# Summary checks

Argos Summary Checks: Simplify merge decisions with a unified view of commit statuses, enhancing your workflow with configurable, insightful checks.

![Summary status check in GitHub](./summary-checks/summary-check.png)

They are particularly useful to [setup required status checks before merging](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches#require-status-checks-before-merging) a pull request.

![Required Argos status check in GitHub](./summary-checks/required-status-check.png)

## Options for Summary Checks

There are three configurations for summary checks:

1. **Add a summary check only if there is more than one build**:
   - This is recommended for most projects. It adds a summary check to help you quickly see the combined status of multiple builds.

2. **Always add a summary check**:
   - This option is useful if your project conditionally runs builds, such as Argos builds. It ensures that you the summary status check will always be present.

3. **Never add a summary check**:
   - Select this if you wish to disable summary checks. This might be preferred if summary checks are not providing additional value to your project's workflow.

Remember, summary checks are an additional layer of status reporting and do not replace individual check statuses.

## Configuring Summary Checks

To configure summary checks for your project, follow these steps:

1. Navigate to the project settings in Argos.
2. Locate the 'Summary Checks' section.
3. Choose the appropriate option based on your project's needs.
4. Click `Save` to apply the changes.

![Configure summary checks in Argos](./summary-checks/configure-summary-checks.png)

---

// File: quickstart/playwright

import {
  Congratulation,
  HelpSection,
  InstallDevDep,
  PlaywrightCaptureScreenshot,
  PlaywrightConfig,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# Playwright Quickstart

Learn how to setup visual testing using the Argos Playwright SDK.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use Playwright](https://playwright.dev/docs/intro#installing-playwright)
- [Run Playwright on your CI/CD](https://playwright.dev/docs/ci-intro#on-pushpull_request)
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

Get the Argos Playwright SDK.

<InstallDevDep dependency="@argos-ci/playwright" />

## 2. Setup Argos in your Playwright config

<PlaywrightConfig />

## 3. Take screenshots

<PlaywrightCaptureScreenshot />
<ScreenshotGuidesLink />

<Congratulation />

## Additional resources

- [Playwright example](https://github.com/argos-ci/argos-javascript/tree/main/examples/playwright)
- [Argos Playwright SDK reference](/playwright)

---

<HelpSection />

---

// File: quickstart/cypress

import {
  AddToGitIgnore,
  Congratulation,
  HelpSection,
  InstallDevDep,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# Cypress Quickstart

Learn how to setup visual testing using the Argos Cypress SDK.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use Cypress](https://docs.cypress.io/guides/getting-started/installing-cypress)
- [Run Cypress on your CI/CD](https://learn.cypress.io/advanced-cypress-concepts/running-cypress-in-ci)
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

Get the Argos Cypress SDK.

<InstallDevDep dependency="@argos-ci/cypress" showCliLink />

## 2. Add `cy.argosScreenshot` command

And add this line to your `cypress/support/e2e.js` file:

```js cypress/support/e2e.js
import "@argos-ci/cypress/support";
```

If you use TypeScript, update your `tsconfig.json`:

```js
{
  "compilerOptions": {
    "types": ["cypress", "@argos-ci/cypress/support"]
  }
}
```

## 3. Register Argos in Cypress config

```js cypress.config.js
const { defineConfig } = require("cypress");
const { registerArgosTask } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  // setupNodeEvents can also be defined in "component"
  e2e: {
    async setupNodeEvents(on, config) {
      registerArgosTask(on, config, {
        // Enable upload to Argos only when it runs on CI.
        uploadToArgos: !!process.env.CI,
        // Set your Argos token (required only if you don't use GitHub Actions).
        token: "<YOUR-ARGOS-TOKEN>",
      });

      // include any other plugin code...
    },
  },
});
```

## 4. Take screenshots

Use <code>argosScreenshot</code> helper to capture stable screenshots in your E2E tests.

```js title="cypress/e2e/homepage.cy.js"
it("screenshot homepage", async ({ page }) => {
  cy.visit("https://localhost:3000/");
  cy.argosScreenshot("homepage");
});
```

<AddToGitIgnore path="/cypress/screenshots" />
<ScreenshotGuidesLink />
<Congratulation />

## Additional resources

- [Cypress example](https://github.com/argos-ci/argos-javascript/tree/main/examples/cypress)
- [Argos Cypress SDK reference](/cypress)

---

<HelpSection />

---

// File: quickstart/webdriverio

import {
  AddSecret,
  Congratulation,
  HelpSection,
  InstallDevDep,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# WebdriverIO Quickstart

Learn how to setup visual testing using the Argos WebdriverIO SDK.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use WebdriverIO](https://webdriver.io/)
- Run WebdriverIO on your CI/CD
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

<InstallDevDep dependency="@argos-ci/cli @argos-ci/webdriverio" showCliLink />

## 2. Take screenshots

Use <code>argosScreenshot</code> helper to capture screenshots in your E2E tests.

```js
import { browser } from "@wdio/globals";
import { argosScreenshot } from "@argos-ci/webdriverio";

describe("Integration test with visual testing", () => {
  it("covers homepage", async () => {
    await browser.url("http://localhost:3000");
    await argosScreenshot(browser, "homepage");
  });
});
```

Screenshots are stored in `screenshots/argos`, don't forget to add this folder to your `.gitignore`.

## 3. Setup your CI

<AddSecret folder="screenshots" />

<Congratulation />

## Additional resources

- [Argos WebdriverIO SDK reference](/webdriverio)

---

<HelpSection />

---

// File: quickstart/puppeteer

import {
  AdditionalResources,
  AddSecret,
  Congratulation,
  HelpSection,
  InstallDevDep,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# Puppeteer Quickstart

Learn how to setup visual testing using the Argos Puppeteer SDK.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use Puppeteer](https://pptr.dev/#getting-started)
- Run Puppeteer on your CI/CD
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

<InstallDevDep dependency="@argos-ci/cli @argos-ci/puppeteer" showCliLink />

## 2. Take screenshots

Use <code>argosScreenshot</code> helper to capture stable screenshots in your E2E tests.

```js
import { argosScreenshot } from "@argos-ci/puppeteer";
const puppeteer = require("puppeteer");

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto("http://example.com");
  await argosScreenshot(page, "example.png");
  await browser.close();
})();
```

<ScreenshotGuidesLink />

## 3. Setup your CI

<AddSecret folder="./screenshots" />

<Congratulation />

## Additional resources

- [Puppeteer example](https://github.com/argos-ci/argos-javascript/tree/main/examples/puppeteer)
- [Argos Puppeteer SDK reference](/puppeteer)

---

<HelpSection />

---

// File: quickstart/next

import {
  Congratulation,
  HelpSection,
  InstallDevDep,
  PlaywrightCaptureScreenshot,
  PlaywrightConfig,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# Next.js Quickstart

Learn how to setup visual testing in a Next.js project using Argos.

The best way to integrate Argos with Next.js is to setup Playwright in your project.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use Next.js](https://nextjs.org/)
- [Install Playwright with Next.js](https://nextjs.org/docs/app/building-your-application/testing/playwright)
- [Run Playwright on your CI/CD](https://nextjs.org/docs/app/building-your-application/testing/playwright#running-playwright-on-continuous-integration-ci)
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

Get the Argos Playwright SDK.

<InstallDevDep dependency="@argos-ci/playwright" />

## 2. Setup Argos in your Playwright config

<PlaywrightConfig />

## 3. Take screenshots

<PlaywrightCaptureScreenshot />
<ScreenshotGuidesLink />

<Congratulation />

## Additional resources

- [Next.js example](https://github.com/argos-ci/argos-javascript/tree/main/examples/nextjs)
- [Argos Playwright SDK reference](/playwright)

---

<HelpSection />

---

// File: quickstart/react-router

import {
  Congratulation,
  HelpSection,
  InstallDevDep,
  PlaywrightCaptureScreenshot,
  PlaywrightConfig,
  ScreenshotGuidesLink,
} from "@site/src/partials";

# React Router Quickstart

Learn how to setup visual testing in a React Router (previously Remix) project using Argos.

The best way to integrate Argos with React Router is to setup Playwright in your project.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- [Use React Router](https://reactrouter.com/)
- [Install Playwright](https://playwright.dev/docs/intro)
- [Run Playwright on your CI/CD](https://playwright.dev/docs/ci-intro#on-pushpull_request)
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

Get the Argos Playwright SDK.

<InstallDevDep dependency="@argos-ci/playwright" />

## 2. Setup Argos in your Playwright config

<PlaywrightConfig />

## 3. Take screenshots

<PlaywrightCaptureScreenshot />
<ScreenshotGuidesLink />

<Congratulation />

## Additional resources

- [React Router example](https://github.com/argos-ci/argos-javascript/tree/main/examples/react-router)
- [Argos Playwright SDK reference](/playwright)

---

<HelpSection />

---

// File: quickstart/e2e-tool

import {
  AddSecret,
  Congratulation,
  HelpSection,
  InstallDevDep,
} from "@site/src/partials";

# Quickstart with any test framework

Learn how to setup visual testing using Argos SDK.

## Prerequisites

To get the most out of this guide, youâ€™ll need to:

- Take screenshots while your E2E tests are running
- Run your E2E tests on CI
- [Create your project in Argos](https://app.argos-ci.com/new)

## 1. Install

<InstallDevDep dependency="@argos-ci/cli" showCliLink />

## 2. Upload screenshots on CI

<AddSecret folder="./screenshots" />

<Congratulation />

## Additional resources

- [Argos CLI reference](/argos-cli)
- [Enrich screenshots with metadata](/screenshot-metadata)

---

<HelpSection />

---

// File: quickstart/storybook/storybook-test-runner

import {
  Congratulation,
  HelpSection,
  InstallDevDep,
  AddToGitIgnore,
} from "@site/src/partials";

# Storybook Test Runner Quickstart

Learn how to setup visual testing in a Storybook using Test Runner + Argos.

## Prerequisites

To get the most out of this guide, you'll need to:

- [Use Storybook v8+](https://storybook.js.org/docs/get-started/install)
- [Create your project in Argos](https://app.argos-ci.com/new)

:::note

If use Vitest and not Test Runner, follow our [Storybook Vitest quickstart](/quickstart/storybook).<br/>
If use a legacy version of Storybook (\<v8), follow our [legacy Storybook quickstart](/quickstart/storybook-legacy).

:::

## 1. Install

<InstallDevDep
  dependency="@argos-ci/cli @argos-ci/storybook @storybook/test-runner"
  showCliLink
/>

## 2. Update your package.json

Add the following scripts to your `package.json`:

```json title="package.json"
{
  "scripts": {
    "test-storybook": "NODE_NO_WARNINGS=1 NODE_OPTIONS=--experimental-vm-modules test-storybook"
  }
}
```

:::note

`NODE_OPTIONS=--experimental-vm-modules` is required because Storybook uses Jest that requires this flag to run modern packages like Argos Storybook SDK.

:::

## 3. Capture screenshots

Add `.storybook/test-runner.ts` file to your project:

```ts title=".storybook/test-runner.ts"
import type { TestRunnerConfig } from "@storybook/test-runner";
import { argosScreenshot } from "@argos-ci/storybook/test-runner";

const config: TestRunnerConfig = {
  async postVisit(page, context) {
    await argosScreenshot(page, context);
  },
};

export default config;
```

It will capture screenshots of your stories in `./screenshots` directory.

<AddToGitIgnore path="./screenshots" />

## 4. Setup CI to run tests and upload screenshots

Below is a complete GitHub Actions workflow to build your Storybook, run tests, capture screenshots, and upload them to Argos.
If you use another CI provider, adapt the steps accordingly.

```yml title=".github/workflows/storybook-test.yml"
name: Storybook Test

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4

      - name: Install dependencies
        run: npm ci

      - name: Build Storybook
        run: npm run build-storybook

      - name: Install Playwright dependencies
        run: npx playwright install --with-deps chromium

      - name: Run Storybook tests and capture screenshots
        run: |
          npx concurrently -k -s first -n "SB,TEST" -c "magenta,blue" \
            "npx http-server ./storybook-static --port 6006 --silent" \
            "npx wait-on tcp:127.0.0.1:6006 && npm run test-storybook"

      - name: Upload screenshots to Argos
        # ðŸ‘‡ Replace `<ARGOS_TOKEN>` with your project token, available in your Argos project settings.
        run: npm exec -- argos upload --token <ARGOS_TOKEN> ./screenshots
```

To learn how to run tests on a deployed Storybook, refer to the [Storybook test runner documentation](https://storybook.js.org/docs/writing-tests/test-runner#set-up-ci-to-run-tests).

<Congratulation />

## Additional resources

- [Argos + Storybook + Test Runner example](https://github.com/argos-ci/argos-javascript/tree/main/examples/storybook-test-runner)
- [Argos Storybook SDK reference](/storybook)
- [Storybook documentation](https://storybook.js.org/docs)
- [Storybook test runner documentation](https://storybook.js.org/docs/writing-tests/test-runner)

---

<HelpSection />

---

// File: quickstart/storybook/index

import {
  Congratulation,
  HelpSection,
  InstallDevDep,
  AddToGitIgnore,
} from "@site/src/partials";

# Storybook Quickstart

Learn how to setup visual testing in a Storybook using Vitest + Argos.

## Prerequisites

To get the most out of this guide, you'll need to:

- [Use Storybook v8+](https://storybook.js.org/docs/get-started/install)
- [Install Storybook Vitest Addon](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon)
- [Create your project in Argos](https://app.argos-ci.com/new)

:::note

If use Test Runner and not Vitest, follow our [Storybook Test Runner quickstart](/quickstart/storybook-test-runner).<br/>
If use a legacy version of Storybook (\<v8), follow our [legacy Storybook quickstart](/quickstart/storybook-legacy).

:::

## 1. Install

<InstallDevDep dependency="@argos-ci/storybook" showCliLink />

## 2. Add Argos plugin to your Vitest configuration

The Argos plugin for Vitest captures screenshots of your stories and uploads them to Argos. Add it to your Vitest or Vite configuration file (e.g., `vitest.config.ts` or `vite.config.ts`):

```ts title="vitest.config.ts"
import path from "node:path";
import { fileURLToPath } from "node:url";

import { defineConfig } from "vitest/config";

import { storybookTest } from "@storybook/addon-vitest/vitest-plugin";
// highlight-next-line
import { argosVitestPlugin } from "@argos-ci/storybook/vitest-plugin";

const dirname =
  typeof __dirname !== "undefined"
    ? __dirname
    : path.dirname(fileURLToPath(import.meta.url));

// More info at: https://storybook.js.org/docs/next/writing-tests/integrations/vitest-addon
export default defineConfig({
  test: {
    projects: [
      {
        extends: true,
        plugins: [
          // The plugin will run tests for the stories defined in your Storybook config
          // See options at: https://storybook.js.org/docs/next/writing-tests/integrations/vitest-addon#storybooktest
          storybookTest({ configDir: path.join(dirname, ".storybook") }),

          // highlight-start
          // The plugin will capture screenshots of your stories and upload them to Argos.
          // See options at: https://argos-ci.com/docs/storybook
          argosVitestPlugin({
            // Upload to Argos on CI only.
            uploadToArgos: !!process.env.CI,

            // Set your Argos token (required if not using GitHub Actions).
            token: "<YOUR-ARGOS-TOKEN>",
          }),
          // highlight-end
        ],
        test: {
          name: "storybook",
          browser: {
            enabled: true,
            headless: true,
            provider: "playwright",
            instances: [{ browser: "chromium" }],
          },
          setupFiles: [".storybook/vitest.setup.ts"],
        },
      },
    ],
  },
});
```

:::note

Be sure to have already installed the [Storybook Vitest Addon](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon) in your project.

:::

## 3. Capture screenshots

All your stories will be automatically captured when you run the tests.

You can also capture screenshots in the [play function](https://storybook.js.org/docs/writing-stories/play-function) by using the `argosScreenshot` function:

```ts title="example.stories.ts"
import { argosScreenshot } from "@argos-ci/storybook/vitest";

export const Example: Story = {
  play: async (ctx) => {
    // It captures a screenshot of the current story and uploads it to Argos
    // See options at: https://argos-ci.com/docs/storybook
    await argosScreenshot(ctx, "example-screenshot");
  },
};
```

It will capture screenshots of your stories in `./screenshots` directory.

<AddToGitIgnore path="./screenshots" />

## 4. Setup CI to run tests and upload screenshots

Argos is just a plugin running on top of Storybook Vitest Addon, so you can run the tests in your CI as you would normally do with Vitest.

To run the tests in your CI, please refer to the [Testing in CI guide of Storybook](https://storybook.js.org/docs/writing-tests/in-ci).

<Congratulation />

## Additional resources

- [Argos + Storybook + Vitest example](https://github.com/argos-ci/argos-javascript/tree/main/examples/storybook-vitest)
- [Argos Storybook SDK reference](/storybook)
- [Storybook documentation](https://storybook.js.org/docs)
- [Storybook Vitest addon documentation](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon)

---

<HelpSection />

---

// File: quickstart/storybook/storybook-legacy

import {
  AddSecret,
  Congratulation,
  HelpSection,
  InstallDevDep,
  AddToGitIgnore,
} from "@site/src/partials";

# Storybook Legacy (\<v8) Quickstart

Learn how to setup visual testing in a Storybook (\<v8) using Argos.

To integrate Argos with a legacy version of Storybook (\<v8), you have to use [Storycap](https://github.com/reg-viz/storycap) to crawl your Storybook and capture screenshots of your components.

## Prerequisites

To get the most out of this guide, you'll need to:

- [Use Storybook < v8](https://storybook.js.org/docs/get-started/install)
- [Create your project in Argos](https://app.argos-ci.com/new)

:::note

If use a recent version of Storybook (>v8), follow our [modern Storybook guide](/quickstart/storybook).

:::

## 1. Install

<InstallDevDep dependency="@argos-ci/cli storycap" showCliLink />

## 2. Capture screenshots

There are two ways to capture screenshots of your Storybook:

- If your Storybook is running and accessible via an URL, add this command to your CI pipeline to capture screenshots of your stories:

```sh
# Capture screenshots of your stories
npm exec -- storycap <STORYBOOK-URL> --outDir ./screenshots
```

- If your Storybook is not deployed, you need to serve your Storybook before capturing the screenshots. Use the following commands:

```sh
# Build Storybook
npm exec -- storybook build --output-dir ./storybook-static

# Screenshot Storybook with Storycap
npm exec -- storycap --serverCmd "npx http-server ./storybook-static --port 6006" http://127.0.0.1:6006/ --outDir ./screenshots
```

Read the [Storycap documentation](https://github.com/reg-viz/storycap) to learn more about the installation and advanced usages.

<AddToGitIgnore path="./screenshots" />

## 3. Upload screenshots on CI

<AddSecret folder="./screenshots" />

<Congratulation />

## Additional resources

- [Argos + Storybook legacy example](https://github.com/argos-ci/argos-javascript/tree/main/examples/storybook-legacy)
- [Storycap documentation](https://github.com/reg-viz/storycap)
- [Storybook documentation](https://storybook.js.org/docs)

---

<HelpSection />

---

// File: sdks/cli

import { InstallDevDep, RunPkgCommand } from "@site/src/partials";

# Argos Command Line Interface (CLI)

Use the Argos CLI for seamless screenshot uploads to our visual testing platform, ideally integrated into your CI workflow.

You can access `@argos-ci/cli` through our [npm package](https://www.npmjs.com/package/@argos-ci/cli). The source code is available on our [GitHub repository](https://github.com/argos-ci/argos-javascript/tree/main/packages/cli).

## Installation

<InstallDevDep dependency="@argos-ci/cli" showCliLink={false} />

## Configuration

Your configuration requirements may vary depending on the CI you use. Typically, you'll need to set ARGOS_TOKEN as a environment variable (ie. secret).

:::note

You can also specify the token with the `--token=<your-repository-token>` argument. However, for security reasons, we recommend using an environment variable instead.

:::

## Upload Command

Use the `upload` command to upload screenshots stored in your `./screenshots` directory.

<RunPkgCommand command="argos upload ./screenshots" />

### Debug mode

You can enable debug mode by setting the `DEBUG` environment variable.

<RunPkgCommand
  command="argos upload ./screenshots"
  envVariable="DEBUG=@argos-ci/core"
/>

## Help Command

To view a list of available options, use the argos help command.

<RunPkgCommand command="argos help upload" />

---

// File: sdks/cypress/index

# Argos Cypress SDK

Boost your visual testing capabilities by combining Argos with your [Cypress](https://www.cypress.io/) tests.

While Cypress inherently provides screenshot functionality, the Argos Cypress integration enhances this by:

- Ensuring all images are fully loaded.
- Ensuring all fonts are rendered.
- Confirming the absence of any `aria-busy` (loading) elements on the page.
- Concealing scrollbars.
- Obscuring text cursors or carets.
- Providing CSS utilities to simplify content hiding.
- Gives you visility on test failures.

## Get started

Please refer to our [Quickstart guide](/quickstart/cypress) to get started with Argos and Cypress.

## Set a Preview URL

Argos displays the URL of the page when a screenshot is taken, helping you understand the screenshotâ€™s context in the Argos UI. If you run tests locally and deploy your pull requests (PRs) to a preview URL, you can link the two by setting the `ARGOS_PREVIEW_URL` environment variable or configuring the `previewUrl` option in the Cypress configuration.

### Example Configuration

```ts title="cypress.config.js"
const { defineConfig } = require("cypress");
const { registerArgosTask } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  e2e: {
    async setupNodeEvents(on, config) {
      registerArgosTask(on, config, {
        uploadToArgos: !!process.env.CI,
        previewUrl: {
          baseUrl: "https://my-site.com", // Use a dynamic value here for different environments if needed.
        },
      });
    },
  },
});
```

## Setup individual Cypress events

Cypress only supports one handler per event. If you need to set up other handlers for the same event, you can call the individual functions provided by the SDK.

```ts title="cypress.config.js"
const { defineConfig } = require("cypress");
const {
  argosAfterScreenshot,
  argosAfterRun,
} = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  // setupNodeEvents can be defined in either
  // the e2e or component configuration
  e2e: {
    async setupNodeEvents(on, config) {
      const argosConfig = {
        uploadToArgos: !!process.env.CI,
      };

      on("after:screenshot", async (details) => {
        // Your custom logic...

        return argosAfterScreenshot(config, details, argosConfig);
      });

      on("after:run", async (results) => {
        // Your custom logic...

        return argosAfterRun(config, results, argosConfig);
      });
    },
  },
});
```

## API Overview

### cy.argosScreenshot([name][, options])

- `name`: Unique name for the screenshot.
- `options`: Explore [cy.screenshot command options](https://docs.cypress.io/api/commands/screenshot) for details.
- `options.element`: Use an ElementHandle or string selector to capture a specific element's screenshot.
- `options.viewports`: Define specific viewports for capturing screenshots. More on [viewports configuration](/viewports).
- `options.argosCSS`: Specific CSS applied during the screenshot process. More on [injecting CSS](/injecting-css)
- `options.threshold`: Sensitivity threshold between 0 and 1. The higher the threshold, the less sensitive the diff will be. Default to `0.5`.
- `options.stabilize`: Wait for the UI to stabilize before taking the screenshot. Set to `false` to disable stabilization. Pass an object to customize the stabilization. Default to `true`.
- `options.stabilize.disableSpellCheck`: Disable spell check before taking the screenshot. Default to `true`.
- `options.stabilize.fontAntialiasing`: Force font antialiasing. Default to `true`.
- `options.stabilize.hideCarets`: Hide text carets before taking the screenshot. Default to `true`.
- `options.stabilize.hideScrollbars`: Hide scrollbars before taking the screenshot. Default to `true`.
- `options.stabilize.loadImageSrcset`: Force the loading of images with `srcset` attributes when the viewport changes. Default to `true`.
- `options.stabilize.roundImageSize`: Round image sizes to the nearest integer. Default to `true`.
- `options.stabilize.stabilizeSticky`: Stabilize sticky and fixed elements by switching to `position: absolute`. Default to `true`.
- `options.stabilize.waitForAriaBusy`: Wait for the `aria-busy` attribute to be removed from the document. Default to `true`.
- `options.stabilize.waitForFonts`: Wait for fonts to be loaded. Default to `true`.
- `options.stabilize.waitForImages`: Wait for images to be loaded. Default to `true`.

## Helper Attributes for Visual Testing

For tailored visual testing, the `data-visual-test` attributes provide control over how elements appear in Argos screenshots. This can be especially useful for obscuring or modifying elements with dynamic content, like dates.

- `[data-visual-test="transparent"]`: Renders the element transparent (`visiblity: hidden`).
- `[data-visual-test="removed"]`: Removes the element from view (`display: none`).
- `[data-visual-test="blackout"]`: Masks the element with a blackout effect.
- `[data-visual-test-no-radius]`: Strips the border radius from the element.

**Example: Using a helper attribute to hide a div from the captured screenshot:**

```html
<div id="clock" data-visual-test="transparent">...</div>
```

### registerArgosTask(on, config[, options])

- `on`: Cypress plugin events.
- `config`: Cypress config.
- `options`: All [upload parameters](https://js-sdk-reference.argos-ci.com/interfaces/UploadParameters.html).
- `options.uploadToArgos`: Upload results and create a build on Argos, `true` by default.

```ts title="cypress.config.js"
const { defineConfig } = require("cypress");
const { registerArgosTask } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  // setupNodeEvents can be defined in either
  // the e2e or component configuration
  e2e: {
    async setupNodeEvents(on, config) {
      registerArgosTask(on, config, {
        uploadToArgos: !!process.env.CI,
      });

      // include any other plugin code...
    },
  },
});
```

### argosAfterScreenshot(config, details[, options])

Cypress "after:screenshot" event handler.

- `config`: Cypress config.
- `details`: Screenshot details provided by Cypress.
- `options`: All [upload parameters](https://js-sdk-reference.argos-ci.com/interfaces/UploadParameters.html).
- `options.uploadToArgos`: Upload results and create a build on Argos, `true` by default.

```ts title="cypress.config.js"
const { defineConfig } = require("cypress");
const { argosAfterScreenshot } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  // setupNodeEvents can be defined in either
  // the e2e or component configuration
  e2e: {
    async setupNodeEvents(on, config) {
      on("after:screenshot", async (details) => {
        // Your custom logic...

        return argosAfterScreenshot(config, details, {
          uploadToArgos: !!process.env.CI,
        });
      });

      // include any other plugin code...
    },
  },
});
```

### argosAfterRun(config, results[, options])

Cypress "after:run" event handler.

- `config`: Cypress config.
- `results`: Run results provided by Cypress.
- `options`: All [upload parameters](https://js-sdk-reference.argos-ci.com/interfaces/UploadParameters.html).
- `options.uploadToArgos`: Upload results and create a build on Argos, `true` by default.

```ts title="cypress.config.js"
const { defineConfig } = require("cypress");
const { argosAfterRun } = require("@argos-ci/cypress/task");

module.exports = defineConfig({
  // setupNodeEvents can be defined in either
  // the e2e or component configuration
  e2e: {
    async setupNodeEvents(on, config) {
      on("after:run", async (results) => {
        // Your custom logic...

        await argosAfterRun(config, results, {
          uploadToArgos: !!process.env.CI,
        });
      });

      // include any other plugin code...
    },
  },
});
```

## Troubleshooting

### Error while importing `@argos-ci/cypress/task` in `cypress.config.ts`

To address the `ts(1479)` error when importing `@argos-ci/cypress/task` in your `cypress.config.ts`, you have two main strategies:

1. Update your `tsconfig.json` by setting `moduleResolution` to `"Bundler"`. This method leverages TypeScript's support for newer module resolution strategies, aligning with Node.js's `exports` feature used by Argos to distribute optimized SDKs.

2. Alternatively, suppress the error in `cypress.config.ts` by adding the line `// @ts-expect-error moduleResolution` right above the import statement. This tells TypeScript to expect an error at this line and ignore it, offering a quick workaround without adjusting your project's module resolution strategy.

The first option is a more comprehensive solution, dealing with the TypeScript bug through adopting the new `moduleResolution: "Bundler"` setting, which is designed for such cases. The second option is simpler and quicker but bypasses the issue rather than solving it at its core.

### Viewports option not working

When running Cypress in headless mode, the [Cypress.viewport](https://docs.cypress.io/api/commands/viewport) command (used internally by `@argos-ci/cypress`) may not behave as expected. This is because headless browsers donâ€™t render a visible viewport, which can result in incorrect or inconsistent screenshots.

To ensure a consistent viewport size, configure it via `setupNodeEvents` in your `cypress.config.js`. This approach sets the viewport before the browser launches, avoiding visual regressions.

```ts title="cypress.config.js"
import { defineConfig } from "cypress";

export default defineConfig({
  // setupNodeEvents can be defined in either
  // the e2e or component configuration
  e2e: {
    setupNodeEvents(on, config) {
      on("before:browser:launch", (browser, launchOptions) => {
        if (browser.name === "chrome" && browser.isHeadless) {
          // fullPage screenshot size is 1400x1200 on non-retina screens
          // and 2800x2400 on retina screens
          launchOptions.args.push("--window-size=1400,1200");

          // force screen to be non-retina (1400x1200 size)
          launchOptions.args.push("--force-device-scale-factor=1");

          // force screen to be retina (2800x2400 size)
          // launchOptions.args.push('--force-device-scale-factor=2')
        }

        if (browser.name === "electron" && browser.isHeadless) {
          // fullPage screenshot size is 1400x1200
          launchOptions.preferences.width = 1400;
          launchOptions.preferences.height = 1200;
        }

        if (browser.name === "firefox" && browser.isHeadless) {
          // menubars take up height on the screen
          // so fullPage screenshot size is 1400x1126
          launchOptions.args.push("--width=1400");
          launchOptions.args.push("--height=1200");
        }

        return launchOptions;
      });
    },
  },
});
```

Reference: [Cypress Docs â€“ Set screen size when running headless](https://docs.cypress.io/api/node-events/browser-launch-api#Set-screen-size-when-running-headless)

## Additional Resources

- [Quickstart with Argos + Cypress](/quickstart/cypress)
- [Example of Argos + Cypress](https://github.com/argos-ci/argos-javascript/tree/main/examples/cypress)
- [@argos-ci/cypress on GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/cypress)
- [@argos-ci/cypress on npm](https://www.npmjs.com/package/@argos-ci/cypress)

---

// File: sdks/nodejs

# Node.js SDK

Empower your Node.js scripts to upload screenshots with the Argos SDK, or craft your own using `@argos-ci/core` for seamless interaction with Argos.

The SDK is available as an [npm package](https://www.npmjs.com/package/@argos-ci/core) and the source code is open sourced on [GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/core).

## Installation

```sh
npm install --save-dev @argos-ci/core
```

## Usage

To upload screenshots from a `./screenshots` directory, you can use the `upload` function provided by the SDK:

```js
import { upload } from "@argos-ci/core";

await upload({ root: "./screenshots" });
```

## API Reference

For a detailed breakdown of the available SDK functions and their use, please refer to the [SDK reference documentation](https://js-sdk-reference.argos-ci.com).

---

// File: sdks/playwright/index

# Argos Playwright SDK

Improve test debugging and boost your visual testing capabilities by combining Argos with your [Playwright](https://playwright.dev/) tests.

## Get started

Please refer to our [Quickstart guide](/quickstart/playwright) to get started with Argos and Playwright.

## Setup Visual Testing

Argos presents a significant advantage over traditional Playwright visual tests with its streamlined approach to managing and reviewing test results:

- **Visual Testing on CI**: With Argos, there's no need to run tests locally or commit screenshots to your repository. This not only saves time but also keeps your repository clean and focused on code rather than binary assets.
- **Fluid UI for Comparison**: Argos intuitive interface makes it easy to spot discrepancies and understand visual changes without the need for cumbersome manual checks.
- **Enhanced Stabilization**: The Argos integration with Playwright takes visual testing to the next level by ensuring stability and consistency in the screenshots captured. Fonts, images, animations, loaders, everything is just stable.

To enable Visual Testing with Playwright, first you have to setup the Argos reporter in your Playwright config:

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";
import { createArgosReporterOptions } from "@argos-ci/playwright/reporter";

export default defineConfig({
  // ... other configurations

  // Setup Argos reporter to send screenshots and traces to Argos.
  reporter: [
    // Use "dot" reporter on CI, "list" otherwise (Playwright default).
    process.env.CI ? ["dot"] : ["list"],

    // Add Argos reporter.
    [
      "@argos-ci/playwright/reporter",
      // Upload only on CI.
      createArgosReporterOptions({ uploadToArgos: !!process.env.CI }),
    ],
  ],
});
```

And use `argosScreenshot` helper to capture stable screenshots in your E2E tests:

```ts title="tests/example.spec.ts"
import { test } from "@playwright/test";
import { argosScreenshot } from "@argos-ci/playwright";

test("screenshot homepage", async ({ page }) => {
  await page.goto("http://localhost:3000");
  await argosScreenshot(page, "homepage");
});
```

## Setup Tests Debugging

The Argos Playwright reporter automatically reports failure screenshots and playwright traces. You can access them directly in Argos UI. If you are tired to download traces from artifact and run a command to see them, it is the solution for you.

- **Failure Screenshots**: View failure screenshots from your CI tests directly in Argos. No extra steps, just immediate clarity where you need it most.
- **Playwright Traces**: â€œTime travelâ€ through your failing tests with remote Playwright traces. Gain a complete, step-by-step visual journey to the heart of any test issue.

To enable Test Debugging, you have to add Argos reporter and to turn on [Playwright test use options](https://playwright.dev/docs/test-use-options) in your Playwright config:

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";
import { createArgosReporterOptions } from "@argos-ci/playwright/reporter";

export default defineConfig({
  // ... other configurations

  // Setup Argos reporter to send screenshots and traces to Argos.
  reporter: [
    // Use "dot" reporter on CI, "list" otherwise (Playwright default).
    process.env.CI ? ["dot"] : ["list"],

    // Add Argos reporter.
    [
      "@argos-ci/playwright/reporter",
      // Upload only on CI.
      createArgosReporterOptions({ uploadToArgos: !!process.env.CI }),
    ],
  ],

  // Setup recording option to enable test debugging features.
  use: {
    // Collect trace when retrying the failed test.
    trace: "on-first-retry",

    // Capture screenshot after each test failure.
    screenshot: "only-on-failure",
  },
});
```

## Tests Sharding

Argos seamlessly integrates with [Playwright test sharding](https://playwright.dev/docs/test-sharding), enabling efficient test distribution without the need for manual configuration. [Argos Sharding/Parallel mode](/parallel-testing) is automatically configured for you.

Argos also supports [Currents orchestration](https://currents.dev/) using [Argos parallel + finalize](/parallel-testing).

## Helper Attributes for Visual Testing

For tailored visual testing, the `data-visual-test` attributes provide control over how elements appear in Argos screenshots. This can be especially useful for obscuring or modifying elements with dynamic content, like dates.

- `[data-visual-test="transparent"]`: Renders the element transparent (`visiblity: hidden`).
- `[data-visual-test="removed"]`: Removes the element from view (`display: none`).
- `[data-visual-test="blackout"]`: Masks the element with a blackout effect.
- `[data-visual-test-no-radius]`: Strips the border radius from the element.

**Example: Using a helper attribute to hide a div from the captured screenshot:**

```html
<div id="clock" data-visual-test="transparent">...</div>
```

## Create multiple Argos builds from a single suite of tests

To generate multiple Argos builds from a single suite of Playwright tests, use a dynamic `buildName`. This object contains two properties:

- `values`: An array of possible values returned by the `get` function.
- `get`: A function that takes a [test case](https://playwright.dev/docs/api/class-testcase) as an argument and returns the build name.

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";
import { createArgosReporterOptions } from "@argos-ci/playwright/reporter";

export default defineConfig({
  // ... other configurations

  reporter: [
    // Use "dot" reporter on CI, "list" otherwise (Playwright default).
    process.env.CI ? ["dot"] : ["list"],

    // Argos reporter
    [
      "@argos-ci/playwright/reporter",
      createArgosReporterOptions({
        uploadToArgos: !!process.env.CI,
        buildName: {
          values: ["app", "website"],
          // Split Argos build based on Playwright tags
          // Learn more about Playwright tags: https://playwright.dev/docs/test-annotations#tag-tests
          get: (test) => (test.tags.includes("@website") ? "website" : "app"),
        },
      }),
    ],
  ],
});
```

## Debug flaky tests

To debug flaky tests, Argos supports using the [Playwright --repeat-each option](https://playwright.dev/docs/test-cli#reference). This runs each test multiple times to detect discrepancies.

```sh
npm exec -- playwright test --repeat-each 5
```

## Configure Content-Security-Policy (CSP)

To stabilize tests, Argos injects a script before taking screenshots. This script may conflict with your CSP settings. To resolve this issue, you have two options:

### 1. Allow the Argos script in your CSP

The `@argos-ci/playwright` package provides a `getCSPScriptHash` method to retrieve the hash of the script injected by Argos. Additionally, Argos requires the `'unsafe-eval'` directive to function properly.

To use this method, you need to be able to inject CSP headers into your server. Here's an example in a Playwright configuration:

```ts
import { defineConfig } from "@playwright/test";
import { getCSPScriptHash } from "@argos-ci/playwright";

export default defineConfig({
  webServer: {
    command: "node my-app.js",
    port: 3000,
    env: {
      CSP_SCRIPT_SRC: `${getCSPScriptHash()},'unsafe-eval'`,
    },
  },
});
```

### 2. Configure Playwright to bypass CSP

If you do not have the flexibility to add custom CSP headers for Playwright test execution, you can [configure Playwright to bypass CSP](https://playwright.dev/docs/api/class-testoptions#test-options-bypass-csp) in your Playwright configuration:

```ts
import { defineConfig } from "@playwright/test";

export default defineConfig({
  use: {
    bypassCSP: true,
  },
});
```

## Set a Preview URL

Argos displays the URL of the page when a screenshot is taken, helping you understand the screenshotâ€™s context in the Argos UI. If you run tests locally and deploy your pull requests (PRs) to a preview URL, you can link the two by setting the `ARGOS_PREVIEW_URL` environment variable or configuring the `previewUrl` option in the Argos reporter.

### Example Configuration

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";
import { createArgosReporterOptions } from "@argos-ci/playwright/reporter";

export default defineConfig({
  reporter: [
    [
      "@argos-ci/playwright/reporter",
      createArgosReporterOptions({
        previewUrl: {
          baseUrl: "https://my-site.com", // Use a dynamic value here for different environments if needed.
        },
      }),
    ],
  ],
});
```

## Test annotations

Argos supports [annotations](https://playwright.dev/docs/test-annotations) added to your tests, providing additional context and information. All annotations are displayed in Argos Build UI, except those where type starts with \_ symbol.

### Example Usage

```ts
import { test, expect } from "@playwright/test";

test(
  "test login page",
  {
    annotation: {
      type: "visual-test",
      description:
        "Critical UI path â€“ ensures login form fields and CTA button align correctly on desktop viewport. Related to regression #1423.",
    },
  },
  async ({ page }) => {
    // ...
  },
);
```

## ARIA Snapshots

Argos allows you to capture ARIA snapshots alongside your screenshots, enhancing accessibility testing. ARIA snapshots provide a structured representation of the page's accessible elements, which can be invaluable for identifying accessibility issues.

### Capture alongside screenshots

You can set `ariaSnapshot: true` in the `argosScreenshot` options to capture an ARIA snapshot along with the screenshot.

```ts title="tests/example.spec.ts"
import { test } from "@playwright/test";
import { argosScreenshot } from "@argos-ci/playwright";

test("screenshot homepage with ARIA snapshot", async ({ page }) => {
  await page.goto("http://localhost:3000");
  await argosScreenshot(page, "homepage", { ariaSnapshot: true });
});
```

:::note

When using the `viewports` option, an ARIA snapshot is captured for each viewport.

:::

### Capture only ARIA snapshot

It is also possible to capture only an ARIA snapshot without a screenshot using the `argosAriaSnapshot` function:

```ts title="tests/example.spec.ts"
import { test } from "@playwright/test";
import { argosAriaSnapshot } from "@argos-ci/playwright";

test("capture ARIA snapshot of homepage", async ({ page }) => {
  await page.goto("http://localhost:3000");
  await argosAriaSnapshot(page, "homepage-aria-snapshot");
});
```

### Billing

Each ARIA snapshot counts as an additional screenshot for billing.

## API Overview

### argosScreenshot(handler, name[, options])

- `handler`: Instance of the [Playwright Page](https://playwright.dev/docs/api/class-page) or [Playwright Frame](https://playwright.dev/docs/api/class-frame).
- `name`: Unique name for the screenshot.
- `options`: Explore [`Page.screenshot` command options](https://playwright.dev/docs/api/class-page#page-screenshot) for details.
- `options.element`: Use a [`Locator`](https://playwright.dev/docs/api/class-locator) or a string selector to capture a specific element's screenshot.
- `options.viewports`: Define specific viewports for capturing screenshots. More on [viewports configuration](/viewports).
- `options.ariaSnapshot`: Capture an ARIA snapshot along with the screenshot. More on [ARIA snapshots](#aria-snapshots).
- `options.argosCSS`: Specific CSS applied during the screenshot process. More on [injecting CSS](/injecting-css)
- `options.disableHover`: Disable hover effects by moving the mouse to the top-left corner of the page. Default to `true`.
- `options.threshold`: Sensitivity threshold between 0 and 1. The higher the threshold, the less sensitive the diff will be. Default to `0.5`.
- `options.root`: Folder where the screenshots will be saved if not using the Argos reporter. Default to `./screenshots`.
- `options.stabilize`: Wait for the UI to stabilize before taking the screenshot. Set to `false` to disable stabilization. Pass an object to customize the stabilization. Default to `true`.
- `options.stabilize.disableSpellCheck`: Disable spell check before taking the screenshot. Default to `true`.
- `options.stabilize.fontAntialiasing`: Force font antialiasing. Default to `true`.
- `options.stabilize.hideCarets`: Hide text carets before taking the screenshot. Default to `true`.
- `options.stabilize.hideScrollbars`: Hide scrollbars before taking the screenshot. Default to `true`.
- `options.stabilize.loadImageSrcset`: Force the loading of images with `srcset` attributes when the viewport changes. Default to `true`.
- `options.stabilize.roundImageSize`: Round image sizes to the nearest integer. Default to `true`.
- `options.stabilize.stabilizeSticky`: Stabilize sticky and fixed elements by switching to `position: absolute`. Default to `true`.
- `options.stabilize.waitForAriaBusy`: Wait for the `aria-busy` attribute to be removed from the document. Default to `true`.
- `options.stabilize.waitForFonts`: Wait for fonts to be loaded. Default to `true`.
- `options.stabilize.waitForImages`: Wait for images to be loaded. Default to `true`.
- `options.beforeScreenshot`: Run a function before taking the screenshot. When using viewports, this function will run before taking sreenshots on each viewport.
- `options.afterScreenshot`: Run a function after taking the screenshot. When using viewports, this function will run after taking sreenshots on each viewport.

Unlike [Playwright's `screenshot` method](https://playwright.dev/docs/api/class-page#page-screenshot), set `fullPage` option to `true` by default. Feel free to override this option if you prefer partial screenshots of your pages.

### argosAriaSnapshot(handler, name[, options])

- `handler`: Instance of the [Playwright Page](https://playwright.dev/docs/api/class-page) or [Playwright Frame](https://playwright.dev/docs/api/class-frame).
- `name`: Unique name for the screenshot.
- `options.element`: Use a [`Locator`](https://playwright.dev/docs/api/class-locator) or a string selector to capture a specific element's screenshot.
- `options.root`: Folder where the screenshots will be saved if not using the Argos reporter. Default to `./screenshots`.
- `options.timeout`: Maximum time in milliseconds. Defaults to `0` - no timeout.
- `options.stabilize`: Wait for the UI to stabilize before taking the screenshot. Set to `false` to disable stabilization. Pass an object to customize the stabilization. Default to `true`.
- `options.stabilize.disableSpellCheck`: Disable spell check before taking the screenshot. Default to `true`.
- `options.stabilize.fontAntialiasing`: Force font antialiasing. Default to `true`.
- `options.stabilize.hideCarets`: Hide text carets before taking the screenshot. Default to `true`.
- `options.stabilize.hideScrollbars`: Hide scrollbars before taking the screenshot. Default to `true`.
- `options.stabilize.loadImageSrcset`: Force the loading of images with `srcset` attributes when the viewport changes. Default to `true`.
- `options.stabilize.roundImageSize`: Round image sizes to the nearest integer. Default to `true`.
- `options.stabilize.stabilizeSticky`: Stabilize sticky and fixed elements by switching to `position: absolute`. Default to `true`.
- `options.stabilize.waitForAriaBusy`: Wait for the `aria-busy` attribute to be removed from the document. Default to `true`.
- `options.stabilize.waitForFonts`: Wait for fonts to be loaded. Default to `true`.
- `options.stabilize.waitForImages`: Wait for images to be loaded. Default to `true`.

### getCSPScriptHash()

Returns the Content-Security-Policy script hash used by Argos (ex: `'sha256-xaC9wWpMVRiAXSfhxhP+Wyqkw0mgO+MIrHuzmMPIxEI='`).

### Playwright reporter

The Argos reporter offers extensive configuration options. Specifically, all [upload parameters](https://js-sdk-reference.argos-ci.com/interfaces/UploadParameters.html) are available for customizing the reporter.

The `createArgosReporterOptions` ensures that your options are correctly typed.

```ts title="playwright.config.ts"
import { defineConfig } from "@playwright/test";
import { createArgosReporterOptions } from "@argos-ci/playwright/reporter";

export default defineConfig({
  // ... other configurations

  reporter: [
    // Use "dot" reporter on CI, "list" otherwise (Playwright default).
    process.env.CI ? ["dot"] : ["list"],

    // Argos reporter
    [
      "@argos-ci/playwright/reporter",
      createArgosReporterOptions({
        uploadToArgos: !!process.env.CI,
        buildName: "custom-build-name",
      }),
    ],
  ],
});
```

## Additional Resources

- [Quickstart with Argos + Playwright](/quickstart/playwright)
- [Argos + Playwright example](https://github.com/argos-ci/argos-javascript/tree/main/examples/playwright)
- [@argos-ci/playwright on GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/playwright)
- [@argos-ci/playwright on npm](https://www.npmjs.com/package/@argos-ci/playwright)

---

// File: sdks/puppeteer/index

# Argos Puppeteer SDK

Integrating Argos with your [Puppeteer](https://github.com/puppeteer/puppeteer) tests to enable visual testing on your application.

Puppeteer already offers a command to take screenshots. The official Argos Puppeteer integration uses it but also does several things:

- Ensuring all images are fully loaded.
- Ensuring all fonts are rendered.
- Confirming the absence of any `aria-busy` (loading) elements on the page.
- Concealing scrollbars.
- Obscuring text cursors or carets.
- Providing CSS utilities to simplify content hiding.

## Installation

### 1. Install package

```
npm install --save-dev @argos-ci/cli @argos-ci/puppeteer
```

### 2. Use in your tests

`argosScreenshot` command stabilizes the UI and takes a screenshot.

_How to take a screenshot with `argosScreenshot` command_

```js
import puppeteer from "puppeteer";
import { argosScreenshot } from "@argos-ci/puppeteer";

describe("Integration test with visual testing", () => {
  it("loads the homepage", async () => {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(TEST_URL);
    await argosScreenshot(page, this.test.fullTitle());
  });
});
```

Screenshots are stored in `screenshots/argos` folder, relative to current directory.

## API Overview

### argosScreenshot(page, name[, options])

- `page` - A `puppeteer` page instance
- `name` - The screenshot name; must be unique. If ends by `.png` we treat it as a path.
- `options` - See [Page.screenshot command options](https://pptr.dev/api/puppeteer.page.screenshot)
- `options.element` - Accept an ElementHandle or a string selector to screenshot an element
- `options.viewports` - Specifies the viewports for which to capture screenshots. See [viewports configuration](/viewports).
- `options.argosCSS`: Specific CSS applied during the screenshot process. More on [injecting CSS](/injecting-css)
- `options.disableHover`: Disable hover effects by moving the mouse to the top-left corner of the page. Default to `true`.
- `options.threshold`: Sensitivity threshold between 0 and 1. The higher the threshold, the less sensitive the diff will be. Default to `0.5`.
- `options.stabilize`: Wait for the UI to stabilize before taking the screenshot. Set to `false` to disable stabilization. Pass an object to customize the stabilization. Default to `true`.
- `options.stabilize.disableSpellCheck`: Disable spell check before taking the screenshot. Default to `true`.
- `options.stabilize.fontAntialiasing`: Force font antialiasing. Default to `true`.
- `options.stabilize.hideCarets`: Hide text carets before taking the screenshot. Default to `true`.
- `options.stabilize.hideScrollbars`: Hide scrollbars before taking the screenshot. Default to `true`.
- `options.stabilize.loadImageSrcset`: Force the loading of images with `srcset` attributes when the viewport changes. Default to `true`.
- `options.stabilize.roundImageSize`: Round image sizes to the nearest integer. Default to `true`.
- `options.stabilize.stabilizeSticky`: Stabilize sticky and fixed elements by switching to `position: absolute`. Default to `true`.
- `options.stabilize.waitForAriaBusy`: Wait for the `aria-busy` attribute to be removed from the document. Default to `true`.
- `options.stabilize.waitForFonts`: Wait for fonts to be loaded. Default to `true`.
- `options.stabilize.waitForImages`: Wait for images to be loaded. Default to `true`.

Unlike [Puppeteer's `screenshot` method](https://playwright.dev/docs/api/class-page#page-screenshot), `argosScreenshot` set `fullPage` option to `true` by default. Feel free to override this option if you prefer partial screenshots of your pages.

## Helper Attributes for Visual Testing

For tailored visual testing, the `data-visual-test` attributes provide control over how elements appear in Argos screenshots. This can be especially useful for obscuring or modifying elements with dynamic content, like dates.

- `[data-visual-test="transparent"]`: Renders the element transparent (`visiblity: hidden`).
- `[data-visual-test="removed"]`: Removes the element from view (`display: none`).
- `[data-visual-test="blackout"]`: Masks the element with a blackout effect.
- `[data-visual-test-no-radius]`: Strips the border radius from the element.

**Example: Using a helper attribute to hide a div from the captured screenshot:**

```html
<div id="clock" data-visual-test="transparent">...</div>
```

## Additional Resources

- [Quickstart with Argos + Puppeteer](/quickstart/puppeteer)
- [@argos-ci/puppeteer on GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/puppeteer)
- [@argos-ci/puppeteer on npm](https://www.npmjs.com/package/@argos-ci/puppeteer)

---

// File: sdks/storybook/index

# Argos Storybook SDK

Integrate visual testing with your Storybook seamlessly using Argos. This SDK allows you to capture and review visual changes in your Storybook components directly within your CI.

## Getting Started

To get started with Argos and Storybook, check out our quick start guides:

- [Storybook + Vitest](/quickstart/storybook).
- [Storybook + Test Runner](/quickstart/storybook-test-runner).
- [Storybook Legacy (\<v8)](/quickstart/storybook-legacy).

## Comparing Argos and Chromatic

While both Argos and Chromatic provide visual testing for Storybook, they take different approaches:

- **Argos** captures screenshots of your Storybook components **in your CI using Playwright**.
- **Chromatic** captures screenshots of your Storybook components **in the cloud**.

For a deeper comparison, see our [Argos vs Chromatic guide](https://argos-ci.com/compare/chromatic).

## Vitest vs Test Runner

Argos supports both [Vitest](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon) and [Test Runner](https://storybook.js.org/docs/writing-tests/integrations/test-runner) for visual testing in Storybook.

Storybook recommends using Vitest for testing and Argos experience is also better if you use it. To learn more about the differences, see [Vitest vs Test Runner comparison guide](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon#comparison-to-the-test-runner).

## Interactions using the play function

The `play` function in Storybook lets you define interactions for your components, ensuring they are in a specific state before capturing a screenshot.

When running tests, either [Vitest](https://storybook.js.org/docs/writing-tests/integrations/vitest-addon) or [Test Runner](https://storybook.js.org/docs/writing-tests/integrations/test-runner) **automatically executes the `play` function** before taking a screenshot.

If you use Vitest, you can also take custom screenshots in your tests using the `argosScreenshot` function:

```ts
import { argosScreenshot } from "@argos-ci/storybook/vitest";

export const FormStory: Story = {
  play: async (ctx) => {
    const { canvasElement } = ctx;

    // Take a screenshot before filling the form
    await argosScreenshot(ctx, "before-fill");

    const canvas = within(canvasElement);

    await userEvent.type(
      canvas.getByLabelText("Email", { selector: "input" }),
      "example-email@email.com",
      { delay: 100 },
    );

    // Take a screenshot after filling the form
    await argosScreenshot(ctx, "after-fill");

    await userEvent.click(canvas.getByRole("button"));
  },
};
```

## Story Modes

Argos supports Story modes to capture different states of your components. Read our [Story modes guide](/storybook-story-modes) for more details.

## Fit to Content vs Page

By default, Argos screenshots are cropped to fit the rendered component (`fitToContent: true`). You can capture the entire page instead by setting `argos.parameters.fitToContent` to `false`.

### Per Story

```ts title="src/components/ProductPage/ProductPage.stories.js"
import { ProductPage } from "./ProductPage";
import { allModes } from "../../../.storybook/modes";

export default {
  title: "Pages/ProductPage",
  component: ProductPage,
  parameters: {
    argos: {
      fitToContent: false,
    },
  },
};
```

### Project-Wide Setting

```ts title=".storybook/preview.js"
import { allModes } from "./modes";

const preview = {
  parameters: {
    argos: {
      fitToContent: false,
    },
  },
};

export default preview;
```

### Options

- **`fitToContent`**: Adjusts the screenshot to the content size (default: `true`).
- **`fitToContent.padding`**: Sets padding around the content in pixels (default: `16`).
- **`fitToContent.zoom`**: Specifies the zoom level (default: `2`).

## Troubleshooting

### My addon is not working with Vitest

To be sure that your addons are properly loaded when running Vitest, be sure to specify your addon annotations in `setProjectAnnotations`:

**Example for `storybook-addon-pseudo-states`**:

```ts
import { setProjectAnnotations } from "@storybook/react-vite";
import * as projectAnnotations from "./preview";
import * as addonAnnotations from "storybook-addon-pseudo-states/preview";

setProjectAnnotations([projectAnnotations, addonAnnotations]);
```

Read more in the [Storybook documentation](https://storybook.js.org/docs/api/portable-stories/portable-stories-vitest#setprojectannotations).

## API Overview

### `@argos-ci/storybook/vitest-plugin`

Exposes the Vitest plugin to capture screenshots of your Storybook stories during tests.

```ts
import { argosVitestPlugin } from "@argos-ci/storybook/vitest-plugin";
import { defineConfig } from "vitest/config";
export default defineConfig({
  plugins: [
    argosVitestPlugin({
      uploadToArgos: true, // Set to false to disable uploading
      buildName: "My Build Name", // Optional build name
    }),
  ],
});
```

- **`uploadToArgos`**: Set to `true` to upload screenshots to Argos CI.

Also supports all options from the [Playwright `argosScreenshot` function](/playwright#argosscreenshotpage-name-options) and [upload parameters](https://js-sdk-reference.argos-ci.com/interfaces/UploadParameters.html).

### `@argos-ci/storybook/vitest`

Take a screenshot of the Story inside the `play` function of a Storybook story (only available when using Vitest).

```ts
import { argosScreenshot } from "@argos-ci/storybook/vitest";

export const Example: Story = {
  play: async (ctx) => {
    // Take a screenshot of the story
    await argosScreenshot(ctx, "example-screenshot");
  },
};
```

- **`ctx`**: The Storybook context provided to the `play` function.
- **`name`**: A name for the screenshot.

### `@argos-ci/storybook/test-runner`

### argosScreenshot(page, context[, options])

Take a screenshot of the Story inside the `postVisit` hook of the Storybook Test Runner.

```ts
import { type TestRunnerConfig } from "@storybook/test-runner";
import { argosScreenshot } from "@argos-ci/storybook/test-runner";

const config: TestRunnerConfig = {
  async postVisit(page, context) {
    await argosScreenshot(page, context);
  },
};

export default config;
```

- **`page`**: The [Playwright Page](https://playwright.dev/docs/api/class-page) instance.
- **`context`**: The test context provided by the Storybook test runner.
- **`options`**: Customizable options for `argosScreenshot`. Explore [available options](/playwright#argosscreenshotpage-name-options).

## Additional Resources

- [Quickstart with Argos + Storybook + Vitest](/quickstart/storybook)
- [Quickstart with Argos + Storybook Test Runner](/quickstart/storybook-test-runner)
- [Quickstart with Argos + Storybook Legacy (\<v8)](/quickstart/storybook-legacy)
- [Argos + Storybook Test Runner example](https://github.com/argos-ci/argos-javascript/tree/main/examples/storybook-test-runner)
- [Argos + Storybook Vitest example](https://github.com/argos-ci/argos-javascript/tree/main/examples/storybook-vitest)
- [@argos-ci/storybook on GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/storybook)
- [@argos-ci/storybook on npm](https://www.npmjs.com/package/@argos-ci/storybook)

---

// File: sdks/webdriverio/index

# Argos WebdriverIO SDK

Integrating Argos with your [WebdriverIO](https://webdriver.io) tests to enable visual testing on your application.

## Get started

Please refer to our [Quickstart guide](/quickstart/webdriverio) to get started with Argos and WebdriverIO.

## API Overview

### argosScreenshot(browser, name[, options])

- `browser` - A `WebdriverIO.Browser` instance
- `name` - The screenshot name; must be unique. If ends by `.png` we treat it as a path.
- `options` - Options
- `options.mask` - Specify ares that should be masked when the screenshot is taken. Masked elements will be overlaid with a pink box #FF00FF (customized by `maskColor`) that completely covers its bounding box.
- `options.maskColor` - Specify the color of the overlay box for masked elements, in CSS color format. Default color is pink #FF00FF.

## Additional Resources

- [Quickstart with Argos + WebdriverIO](/quickstart/webdriverio)
- [@argos-ci/webdriverio on GitHub](https://github.com/argos-ci/argos-javascript/tree/main/packages/webdriverio)
- [@argos-ci/webdriverio on npm](https://www.npmjs.com/package/@argos-ci/webdriverio)